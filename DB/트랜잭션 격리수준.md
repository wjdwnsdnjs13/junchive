# READ UNCOMMITTED
- **커밋하지 않은 데이터도 접근 가능**
- 다른 트랜잭션의 작업이 커밋 또는 롤백되지 않아도 즉시 보임.
- Dirty Read 발생 가능성 존재.

> Dirty Read(오손 읽기)  
>다른 트랜잭션의 작업이 종료되지 않았음에도 읽을 수 있는 데이터 부정합 문제.  
>데이터가 조회되다가 사라지는 문제를 일으킬 수 있음.

# READ COMMITTED
- 커밋된 데이터만 조회
- Phantom Read와 Non-Repeatable Read 문제 발생 가능성 존재
- SELECT에서 트랜잭션 내외부 상관 없이 차이가 별로 없음.
  - 애초에 커밋된 데이터만 가져올 수 있기 때문임.

> Phantom Read  
트랜잭션이 끝나기 전 다른 트랜잭션에 의해 추가된 레코드가 발견되는 상황

# REPEATABLE READ
- 한 트랜잭션 내에서 동일한 결과를 보장함.
- 새로운 레코드 추가에서는 부정합이 생길 수 있음.
- 일반적으로 RDBMS는 변경 전의 레코드를 Un-do 공간에 백업함.
  - 변경 전/후 데이터가 모두 존재함(MVCC : Multi-Version Concurrency Control, 다중 버전 동시성 제어)
- Un-do 로그에 트랜잭션 번호와 함께 변경 기록을 저장함.
- 트랜잭션 번호를 비교해 자신보다 늦게 실행된 트랜잭션은 언두 로그를 참고해 데이터를 조회함.
- **MVCC** 덕에 MySQL에서는 팬텀 리드가 거의 발생하지 않음.
  - **Lock**이 걸렸을 경우엔 데이터 조회가 언두 로그가 아닌 테이블에서 수행되기 때문에 발생할 수 있음.
  - 언두 로그는 append Only의 형태라 잠금 장치가 없어서라고 함.

> 갭 락(Gap Lock)  
인덱스 범위 중 실제 레코드를 제외하고 데이터가 추가될 수 있는 범위에 걸림.  
인덱스는 정렬된 순서로 존재하기에 현존하는 레코드의 앞 뒤로 갭 락이 걸림.  
아직 존재하지 않지만, 지정된 범위에 해당하는 인덱스 테이블 공간을 대상으로 거는 잠금  
e.g) 2와 3이라는 레코드 존재하고, 1 ~ 5 조회 시 1과 4,5가 추가될 수 있는 공간에 걸림.

> 넥스트 키 락(Next Key Lock)  
레코드 락 + 갭 락, 보통 갭 락은 넥스트 키 락과 함께 사용됨.  


# SERIALIZABLE
- 가장 엄격한 격리 수준
- 여러 트랜잭션이 동일한 레코드에 동시 접근 불가.
- 동시 처리 성능이 매우 떨어짐.
- 순수한 SELECT 문에서도 넥스트 키 락을 읽기 잠금으로 건다.


# 주의 사항
- 위의 트랜잭셔널 격리 수준은 모두 AUTO COMMIT이 false인 상태에서만 동작함.

# 추가 공부 사항
- MySQL 락 종류
  - 레코드 락, 갭 락, 넥스트 키 락, Auto Increament Lock
- SELECT ... FOR UPDATE(베타적 잠금, 쓰기 잠금)
- SELECT ... LOCK IN SHARE MODE(읽기 잠금)