# 3장 - 구글 맵
## 1단계 - 문제 이해 및 설계 범위 확정
- Q) DAU는?
  - A) 10억
- Q) 초점을 맞추는 기능은? e.g)방향 안내, 경로 안내, 예상 도착 시간(Estimated Time of Arrival, ETA) 등
  - A) 위치 갱신, 경로 안내, ETA 등에 초점을 맞춤
- Q) 도로 데이터는 어느 정도 규모인가? 도로 데이터는 있다는 가정 하에 진행하는가?
  - A) 도로 데이터는 다양한 경로로 확보해 두었다고 가정. 수 TB 수준의 가공되지 않은 데이터임.
- Q) 교통 상황도 고려해야 하는가?
  - A) 교통 상황은 도착 시간을 최대한 정확하게 추정하는 데 아주 중요함
- Q) 어떻게 이동하는지도 고려하는가?(이동 수단)
  - A) 다양한 이동 방법을 지원할 수 있어야 함.
- Q) 경로 안내 시 경유지를 여러 곳 설정 가능한가?
  - A) 경유지는 좋지만, 우선은 제외함.
- Q) 사업장 위치 및 사진도 표시해야하는가?
  - A) 사진은 우선 고려하지 않음

### 기능 요구 사항
- 사용자 위치 갱신
- 경로 안내 서비스(ETA 서비스 포함)
- 지도 표시
- 주 지원 단말은 모바일

### 비기능 요구사항 및 제약사항
- 정확도
- 부드러운 경로 표시
- 데이터 및 배터리 사용량
- 일반적으로 널리 통용되는 가용성 및 규모 확장성 요구 만족

### 지도 101 - 측위 시스템
- 측위 시스템은 축을 중심으로 회전하는 구에서 표면 상의 위치를 표현하는 체계
- 위도
  - 주어진 위치가 얼마나 북쪽/남쪽인지
- 경도
  - 얼마나 동쪽/서쪽인지

### 지도 101 - 3차원 위치의 2차원 변환
- 지도 투영법 또는 도법
  - 3차원 구 위의 위치를 2차원 평면에 대응시키는 절차
- 거의 모든 투영법은 실제 지형의 기하학적 특성을 왜곡한다는 공통점을 가짐

### 지도 101 - 지오코딩
- 주소를 지리적 측위 시스템의 좌표로 변환하는 프로세스
  - 서울 서초구 신반포로 194 -> 37.505664, 127.005844
- 주소를 좌표로 변환하는 것을 역지오코딩이라고 함
- 인터폴레이션 등을 사용해 지오코딩 수행 가능
  - GIS(Geographic Information System)와 같은 다양한 시스템이 제공하는 데이터를 결합한다는 의미
  - GIS는 도로망을 지리적 좌표 공간에 대응시키는 방법을 제공하는 여러 시스템 가운데 하나임

### 지도 101 - 지오해싱
- 지도 위 특정 영역을 영문자와 숫자로 구성된 짧은 문자열에 대응시키는 인코딩 체계
  - 2차원의 평면 공간으로 표현된 지리적 영역 위의 격자를 재귀적으로 더 작은 격자로 분할해 나감
- 맵 타일 관리에 지오해싱을 적용함

### 지도 101 - 지도표시
- 간단하게만 다루고 넘어감
- 가장 기본이 되는 개념은 타일
  - 지도를 하나의 이미지로 표시하는 대신 작은 타일로 쪼개어 표시함
  - 클라이언트는 사용자가 보는 영역과 관계된 타일만 다운받아 모자이크처럼 이어 붙인 다음 화면에 뿌림
  - 타일을 가져올 땐 지도 확대 수준에 따라서 가져온다.
    - 전체 지도를 다 보려고 할 때 모든 타일을 가져오는 것이 아니라 전세계를 특정 픽셀로 나타낸 타일 하나만 다운받는 형식

### 지도 101 - 경로 안내 알고리즘을 위한 도로 데이터 처리
- 대부분의 경로 탐색 알고리즘은 다익스트라나 A* 경로 탐색 알고리즘을 활용함
  - 최적의 알고리즘 하나를 고르는 것은 어려우므로 패스함
- 중요한 것은 교차로를 노드, 도로를 노드를 잇는 선으로 표현한다는 것
- 경로 탐색 알고리즘의 성능은 주어진 그래프 크기에 아주 민감함
  - 그래프의 크기가 커질수록 메모리도 많이 필요하고 탐색 시간이 길어짐
  - 지오해싱과 비슷한 방법으로 세계를 작은 격자로 나누고, 격자 안의 도로망을 그래프로 만들어 탐색 범위를 줄이는 방법이 있음
  - 각 격자는 경로 안내 타일(routing tile)이라 부름
  - 각 타일은 도로로 연결된 다른 타일에 대한 참조(reference)를 가지고 있음
  - 이렇게 해야 경로 탐색 알고리즘이 연결된 타일들을 지나갈 때 보일 더 큰 도로망 그래프를 만들어낼 수 있다
- 지도 타일은 PNG 이미지지만, 경로 안내 타일은 도로 데이터로 이루어진 이진 파일(binary file)임

### 지도 101 - 계층적 경로 안내 타일
- 경로 안내가 효과적으로 동작하려면 적정한 수준의 구체성을 갖춘 데이터가 필요함.
  - 너무 세분화된 데이터는 메모리 차지는 물론 너무 많은 시간이 걸릴 수 있음
- 보통 구체성 정도를 상/중/하 정도로 구분해 경로 안내 타일을 준비함
  - 지방도 데이터(local roads) -> 상
  - 더 넓게 규모가 큰 관할구(district)를 잇는 간선 도로(arterial roads) 데이터 -> 중
  - 구체성이 가장 낮은 도시와 도시를 연결하는 주요 고속도로 데이터 -> 하
  - 각 타일에는 다른 정밀도 타일로 연결되는 선(edge)가 있을 수 있음

### 개략적 규모 추정
- 설계 초점이 모바일 단말이므로 데이터 사용량과 배터리 효율을 중요하게 봐야함

### 개략적 규모 추정 - 저장소 사용량
- 저장해야할 데이터
  - 서계 지도
  - 메타데이터(metadata)
    - 각 지도 타일의 메타데이터는 크기가 아주 작아서 무시해도 될 정도이므로 패스함
  - 도로 정보
    - 외부에서 받은 수 TB 용량의 도로 데이터를 안내 타일로 변환
    - 변환 결과의 용량도 비슷할 것이라 예상

### 개략적 규모 추정 - 저장소 사용량 : 세계지도
- 지원하는 확대 수준(zoom level) 별로 지도 타일을 한 벌씩 두어야함
- 타일을 보관하는 데 필요한 용량을 가늠하려면 최대 확대 수준의 필요 타일 개수를 따져보는 것이 좋음
- 지도 확대 마다 4장의 타일로 펼친다고 가정
  - 세계 지도를 4의 제곱형태로 펼치므로 21번 확대하면 4.4조 개의 타일이 필요.
  - 256 * 256 픽셀의 압축 PNG 파일은 한 장에 100KB 정도의 용량이 필요함
  - 4.4조 * 100KB = 440PB
  - 다만, 사람이 살지 않는 지역 등에서는 높은 비율로 압축 가능하므로 80% 이상의 저장 용량을 절감할 수도 있다.
- 모든 수준의 타일을 표현하려면 100PB 정도 필요할 것 같음
  - 최대 수준의 타일을 50PB이라고 가정
  - 50PB + 50PB / 4 + 50PB / 16 + ... = 67PB 
  - 각 수준 별로 저장하는 타일 수는 1/4 수준으로 점점 줄어듦

### 개략적 규모 추정 - 서버 대역폭
- 서버 대역폭 추정을 위해서는 어떤 유형의 요청을 처리해야 하는지 살펴봐야 함
  - 경로 안내 요청
    - 클라가 경로 안내 세션을 시작할 때 전송하는 메시지
    - 사용자가 주 당 35분 사용한다고 가정
    - 주 350억 분, 하루에 50억 분
  - 위치 갱신 요청
    - 경로 안내 진행하는 동안 변경된 사용자 위치를 전송하는 메시지
  - 단순하게 매 초 GPS 좌표를 요청하면 하루 3000억 건의 요청이 발생(50억 분 * 60)
    - 300만 QPS
    - 갱신 요청 주기를 15초나 30초로 하면 QPS를 낮출 수 있음
    - 15초로 할 경우 20만 QPS로 확 줄어듦
      - 최대 QPS는 5배로 가정하면 약 100만 QPS


## 2단계 - 개략적 설계안 제시 및 동의 구하기
### 개략적 설계안 - 위치 서비스
- 클라이언트가 t초마다 위치를 갱신하고 서버에 전송
  - 주기적으로 전송되는 위치 정보 전송의 장점
    - 해당 데이터 스트림을 활용해 시스템을 개선할 수 있음
      - 실시간 교통 상황 모니터링, 새로 만들어진 도로나 폐쇄된 도로 탐지, 행동을 분석해 개인화된 경험 제공에 활용
    - 클라가 보내는 정보는 거의 실시간 정보에 가까워 ETA를 더 정확하게 산출 가능
      - 교통 상황에 따라 경로를 조절할 수도 있음
  - 위치 이력을 클라에서 버퍼링 했다가 일괄 요청(batch request)하면 전송 빈도를 줄일 수 있음
  - 위치 갱신 요청 빈도를 줄여도 여전히 많은 쓰기 작업이 진행됨
    - 많은 쓰기 요청에 최적화되고 규모 확장이 용이한 카산드라 같은 DB가 유용함
    - kafka 같은 스트림 엔진을 통해 처리해야할 수도 있음
- 통신 프로토콜
  - HTTP에서 keep-alive를 함께 사용하면 효율을 높일 수 있음

### 개략적 설계안 - 경로 안내 서비스
- A에서 B까지 합리적으로 가장 빠른 경로를 찾아주는 역할
- 최단 경로일 필요는 없으나, 정확도는 보장되어야 함
- 예시 결과물
```json
{
  'distance': {'text': '0.2mi', 'value': 259},
  'duration': {'text': '1 min1, 'value': 83},
    'end_location': {'lat': 37.4038943, 'Ing': -121.9410454},
    'html_instructions': 'Head <b>northeast</b> on <b>Brandon St</b>...',
    'polyline': {'points': '...'},
    'start_location': {'lat': 37.4027165, 'lng': -121.9435809},
    'geocoded_waypoints': [
      {
        "geocoder_status": "OK",
        "partial_match": true,
        "place_id": "...",
        "types": ["locality", "political"]
      },
      {
        "geocoder_status": "OK",
        "partial_match": true,
        "place_id": "...",
        "types": ["locality", "political"]
      }
    ],
    'travel_mode': 'DRIVING'
  }
```
- 경로 재탐색이나 교통 상황 변화에 따른 문제는 고려하지 않았음
  - 적응형 ETA(adaptive ETA)를 통해 해결

### 개략적 설계안 - 지도 서비스
- 확대 수준 별 한 벌씩 지도 타일 저장을 위해서는 수백 PB가 필요함
- 확대 수준에 따라 서버에서 필요한 타일을 가져오는 것이 바람직 함
  - 사용자가 지도를 확대 또는 이동시키며 주변 탐색 시
  - 경로 안내 중 사용자 위치가 현재 지도 타일을 벗어나 인접 타일로 이동 시
- 다량의 지도 타일 데이터를 서버에서 효과적으로 가져오기 위한 방법
  - 확대 수준에 근거해 필요한 지도 타일을 즉석에서 만드는 방법
    - 사용자 위치와 확대 수준의 조합이 무한하므로 문제가 생길 수 있음
      - 모든 지도 타일을 동적으로 만들면 서버 클러스터에 부하가 심각함
      - 캐시 활용이 어려움
    - 확대 수준 별 미리 만들어둔 지도 타일을 전달
      - 각 지도 타일은 지오해싱 같은 분할법을 사용해 만들어진 정적인 타일임
      - 지도 타일이 필요하면 현재 확대 수준에 근거해 필요한 지도 타일 집합을 결정하고 각 위치의 지오해시 URL로 변환
      - 미리 만들어둔 정적 이미지는 CDN을 통해 서비스
        - CDN을 통해 접근 시 한 번 접근한 적이 있는 타일은 서버에 다시 요청하지 않아도 됨
        - 또한 POP(Point of Presence)에 캐시되므로 규모 확장에도 용이함
- 모바일 유저에서는 데이터 사용량도 중요하다.
  - 우선 클라이언트 측 캐시는 고려하지 않음
    - 일반적으로 사람들이 많이 사용하는 길은 캐시에 두면 데이터 사용량을 줄일 수 있음
  - 사용자가 30km/h로 이동, 한 이미지가 200m * 200m 크기라고 가정
    - 이미지는 256 * 256 픽셀, 평균 이미지 크기는 100kb
    - 1km * 1km 지역은 25장의 이미지로 표현 가능
    - 이는 2.5MB(25장 * 100kb)의 데이터를 전송해야 함
    - 30km/h 속도로 이동 시 시간당 75MB 데이터가 소진(30km/h * 1시간 * 2.5MB)
    - 분 당 1.25MB에 해당
- CDN을 통해 서비스되는 트래픽 규모
  - 매일 50억 분 가량의 경로 안내를 처리함
  - 50억 분 * 1.25MB = 6.25PB/Day
  - 초 당 62_500MB
  - 이는 전 세계 여러 POP을 통해 제공되므로 각 POP이 감당하는 트래픽은 수백 MB 정도일 수 있음
- 2번째 미리 만들어준 지도 타일을 사용하는 방식에서 CDN에서 가져올 지도 타일 URL을 결정하는 방법
  - 지오해시를 통해 격자를 나누므로 모든 격자는 고유한 지오해시 값을 가짐
  - 위도/경도로 표현된 클라의 위치와 지도 확대 수준과 매칭되는 지도 타일의 지오해시는 쉽게 계산 가능
  - 해당 계산은 클라가 수행하여 해당 지오해시 및 URL로 CDN에서 지도 타일을 가져오면 됨
  - 클라에서 인코딩 프로세스가 있을 경우 인코딩 교체에 문제가 있을 수 있다
    - 특히 모바일 앱의 경우 교체가 어렵고 위험성도 높다
    - 위도/경도, 확대 수준에 따른 URL을 변환해주는 별도의 서비스를 두는 것도 방법이 될 수 있음
- 타일 URL 변환 서비스
  - 모바일 사용자가 타일 URL을 가져오기 위해 지도 타일 서비스를 호출
  - 로드밸런서가 해당 요청을 지도 타일 서비스로 전달
  - 지도 타일 서비스는 클라의 위치와 확대 수준을 입력으로 9개의 타일을 계산해 클라로 반환
    - 표시 할 타일 하나와 주변 8개의 타일임
  - 모바일 클라는 해당 타일을 CDN을 통해 다운로드

## 3단계 - 상세 설계
### 데이터 모델 - 경로 안내 타일
- 도로 데이터는 외부 사업자나 기관이 제공한 것을 이용함
  - 해당 데이터는 수 TB에 달하며 지속적으로 개선됨
  - 방대한 양의 도로와 메타데이터(이름, 관할구, 위도, 경도 등 도로 부속 정보)로 구성
  - 그래프 자료 구조 형태로 가공되지 않은 데이터임
    - 주어진 상태 그대로 경로 안내 알고리즘의 입력으로 사용 불가
    - 경로 안내 타일 처리 서비스(routing tile processing service)라 불리는 오프라인 데이터 가공 파이프라인을 주기적으로 실행해 경로 안내 타일로 변환함
    - 도로 데이터에서 발생한 실시간 변경 사항을 반영하기 위함
  - 각 타일에는 그래프의 노드와 선분으로 표현된 해당 지역 내 교차로와 도로 정보가 포함됨
    - 다른 타일의 도로와 연결되는 경우에는 해당 타일에 대한 참조 정보도 포함됨
    - 경로 안내 알고리즘은 이들 타일이 모인 결과로 만들어지는 도로망 데이터를 점진적으로 소비함
- 가공되어 만들어진 타일 저장
  - 그래프 데이터는 메모리에 인접 리스트(adjacency list)로 저장되는 것이 일반적임
  - 하지만, 본 설계안의 타일 데이터는 메모리에 두기엔 양이 너무 많음
  - 그래프의 노드와 선을 DB 레코드로 처리하는 방법은 비용이 많이 발생함
    - 추가로 경로 안내 타일은 DB가 제공하는 기능이 필요 없음
  - S3 같은 객체 저장소에 파일을 보관하고 그 파일을 이용할 경로 안내 서비스에서 적극적으로 캐싱하는 것이 효율적임
  - 인접 리스트를 이진 파일 형태로 직렬화 해주는 패키지는 많음
  - 타일을 보관 시 지오해시 기준으로 분류해두는 것이 좋음
    - 위도와 경도가 주어지면 빠르게 타일을 찾을 수 있음
  
### 데이터 모델 - 사용자 위치
- 아주 값진 데이터임
- 도로 데이터 및 경로 안내 타일 갱신에 사용됨
- 실시간 교통 상황 데이터나 교통 상황 이력 DB 구축에도 활용 됨
- 데이터 스트림 프로세싱 서비스는 이 위치 데이터를 처리해 지도 데이터를 갱신
- 사용자 위치 데이터를 저장하기 위해선 엄청난 양의 쓰기 연산을 처리하면서 수평 확장이 가능한 DB가 좋음
  - 카산드라 같은 DB가 좋은 후보임

### 데이터 모델 - 지오코딩 데이터
- 주소를 위도/경도 쌍으로 변환하는 정보를 보관
- 레디스처럼 빠른 읽기 연산을 제공하는 key-value 저장소가 적당함
- 읽기는 빈번하지만 쓰기는 드물기 때문임
- 출발지와 목적지 주소는 경로 계획 서비스에 전달 전 이 DB를 통해 위도/경로 쌍으로 변환되어야 함

### 데이터 모델 - 미리 계산해 둔 지도 타일 데이터
- 특정 영역의 지도를 요청하면 인근 도로 정보를 취합해 모든 도로 및 관련 상세 정보가 포함된 이미지를 만들어야 함
- 계산 자원도 많이 사용하고 같은 이미지가 중복 요청되는 경우가 많음
- 이미지는 확대 수준 별로 미리 만들어 CDN을 통해 전송하는 것이 좋음

### 서비스 - 위치 서비스
- 사용자 위치 데이터 저장에는 key-value 저장소를 활용
- 초당 백만 건의 위치 정보 갱신이 발생하기에 쓰기 연산 성능이 중요함
  - NoSQL key-value DB나 열-중심 DB(column-oriented DB)가 적합함
- 사용자 위치는 계속 변경되고 이전 데이터는 필요없어질 수 있음
  - 데이터 일관성보다는 가용성이 더욱 중요함
  - 따라서 가용성과 분할 내성 두 가지 목적에 집중
- DB 키는 (user_id, timestamp)의 조합으로 사용
  - value에는 위도/경도 쌍을 저장
  - user_id는 파티션 키
    - 특정 사용자의 최근 위치를 신속히 읽어 내기 위해
  - timestamp는 클러스터링 키로 활용
  - 같은 파티션 키를 갖는 데이터는 함께 저장되며 클러스터링 키 값에 따라 정렬됨
    - 특정 사용자의 특정 기간 내 위치도 효율적으로 읽을 수 있음

### 사용자 위치 데이터의 이용
- 사용자 위치는 쓰임새가 다양한 중요 데이터임
  - 새 도로 개설이나 폐쇄된 도로 감지 가능
  - 지도 데이터 정확성 개선에 활용 가능
  - 실시간 교통 현황 파악 가능
- 이런 경우를 지원하기 위해 사용자 위치를 DB에 기록하는 것과 별도로 카프카 같은 메시지 큐에 로깅함
- 개별 서비스는 카프카를 통해 전달되는 사용자 위치 데이터 스트림을 용도에 맞게 활용할 수 있음

### 지도 표시 - 지도 타일 사전 계산
- 확대 수준 별 지도 타일을 미리 만듦
- 확대 수준 증가에 따라 타일은 4배 늘어나지만, 각 타일의 크기는 여전히 256 * 256 픽셀임
  - 따라서 확대 수준 증가에 따라 타일 전체를 합친 해상도는 4배씩 증가함

### 최적화 - 벡터 사용
- 지도 표시에 WebGL 기술 채택
  - 네트워크를 통해 이미지를 전송하는 대신 경로(path)와 다각형(polygon) 등의 벡터(vector) 정보를 보냄
  - 클라는 수신된 경로와 다각형 정보를 통해 지도를 그려냄
  - 이미지에 비해 훨등한 압축률을 가짐
    - 네트워크 대역폭이 많이 절약 됨
  - 훨씬 매끄러운 지도 확대가 가능
    - 래스터 방식 이미지(rasterized image) 사용 시 클라가 확대 수준을 높이는 순간 이미지가 늘어지고(stretch) 픽셀이 도드라짐
    - 벡터 방식을 사용하면 클라는 각 요소 크기를 적절하게 조정할 수 있어서 훨씬 매끄러운 확대 경험 제공 가능

### 서비스 - 지오 코딩 서비스
- 주소를 위도와 경도 쌍으로 바꿔주는 서비스가 필요함
- 주소 표현 방식은 다양할 수 있음
  - 장소 이름, 지번 등
- 구글의 사례
```json

```
- 경로 안내 서비스는 이 서비스를 호출해 출발지와 목적지 주소를 위도/경도 쌍으로 변환해 다른 서비스 호출에 이용함
### 서비스 - 경로 계획 서비스
- 경로 계획 서비스(route planner service)는 현재 교통 상황과 도로 상태에 따라 최적화된 경로를 제안
- 다른 서비스들과 통신해 최종 결과를 만들어냄

### 서비스 - 최단 경로 서비스
- 출발지와 목적지 위도/경도를 입력 받아 k개 최단 경로를 반환함
  - 교통이나 도로 상황은 고려하지 않음
  - 도로 구조에만 의존해 계산을 수행
  - 도로망 그래프는 거의 정적이므로 캐시해두면 좋음
- 객체 저장소로 저장된 안내 타일에 대해 A* 경로 탐색 알고리즘의 한 형태를 실행함
  - 입력으로 출발지와 목적지의 위도/경도를 받음
    - 이 위치 정보를 지오해시로 변환해 출발지와 목적지 경로 안내 타일을 얻음
  - 출발지 타일에서 시작해 그래프 자료 구조를 탐색해 나감
    - 탐색 범위를 넓히는 과정에서 필요한 주변 타일은 객체 저장소에서 가져옴
    - 같은 지역의 다른 확대 수준 타일로도 연결될 수 있음.
    - 최단 경로가 충분히 확보될 때까지 검색 범위를 확대해 나가면서 필요한 만큼 타일을 가져오는 작업을 반복함

### 서비스 - 예상 도착 시간 서비스
- 최단 경로 목록을 수신하면 예상 도착 시간 서비스(ETA service)가 각 경로에 대한 예상 도착 시간을 계산함
- 예상 도착 시간은 기계 학습을 활용해 현재 교통 상황 및 과거 이력에 근거해 예상 도착 시간을 계산함
- 까다로운 점은 현재 교통 데이터만이 아니라 10분, 20분 뒤 미래의 교통 상황도 예측해야한다는 것임
  - 이는 또 다른 내용의 문제이므로 이번에는 패스

### 서비스 - 순위 결정 서비스
- ETA 예상치를 구한 후 순위 결정 서비스에 관련 정보를 모두 전달해 사용자가 정의한 필터링 조건을 적용함
- 유료 도로 제외, 고속도로 제외 등
- 필터링 후 남은 경로를 소요 시간 순 등으로 정렬해 최단 시간 경로 k개를 구해 경로 안내 서비스에 반환

### 서비스 - 중요 정보 갱신 서비스들
- kafka 위치 데이터 스트림을 구독하고 있다가 중요 데이터를 비동기적으로 갱신해 최신 상태를 유지하는 역할을 담당
  - 실시간 교통 정보 DB나 경로 안내 타일 등
  - 새로 발견된 도로나 폐쇄된 도로 등을 반영해 경로 안내 타일을 지속적으로 갱신함
- 실시간 교통 상황 서비스는 사용자가 보내는 위치 데이터 스트림을 통해 교통 상황 정보를 추출
  - 더욱 정확한 예상 도착 시간 서비스를 제공

### 적응형 ETA와 경로 변경
- 현재는 적응형 ETA와 경로 변경을 허용하지 않음
- 이를 해결하기 위해서는 경로 안내를 받는 모든 사용자를 추적해 교통 상황이 달라질 때마다 각 사용자의 ETA를 변경해 주어야 함
  - 현재 경로 안내를 받는 사용자를 어떻게 추적하는가?
  - 수백만 경로 가운데 교통 변화의 영향을 받는 경로와 사용자를 효율적으로 어떻게 가려내는가?
- 사용자가 안내 받는 모든 경로 타일을 저장하고, 영향을 받는 모든 타일을 검색
  - 보관된 레코드 수가 n이고, 경로 평균 길이가 m이라면 모든 사용자 검색에 드는 시간 복잡도는 O(n * m)임
- 경로 안내를 받는 사용자의 현재 경로 안내 타일과 그 타일을 포함하는 상위 수준의 타일, 그 상위 타일의 상위 타일을 출발지와 목적지가 모두 포함된ㄴ 타일을 찾을 때까지 재귀적으로 더해 보관
  - ETA가 달라지는 사용자는 DB 레코드 마지막 타일에 그 타일에 속하는 사용자
  - 시간 복잡도는 O(n)임
- 교통 상황이 개선되었을 때 일을 해결하진 않음
  - 주기적으로 재계산해 사용자에게 더 짧은 ETA가 발견되면 알리는 방법을 사용할 수 있음

### 전송 프로토콜
- 경로 안내 중 경로 상황이 바뀔 수 있음
  - 데이터를 모바일 클라이언트에게 전송할 안정적인 방법이 필요함
  - 모바일 푸시 알림(mobile push notification), 롱 폴링(long polling), 웹소켓(websocket), 서버 전송 이벤트(SSE, server-sent event) 등이 있음
  - 모바일 푸시 알림은 보낼 수 있는 메시지 크기가 매우 제한적이므로 조심해야함(iOS의 경우 최대 4_096바이트)
    - 웹 애플리케이션은 지원하지 않음
  - 웹소켓은 서버에 주는 부담이 크지 않아서 일반적으로 롱 폴링보다 좋은 방안으로 봄
  
## 4단계 - 마무리
- 추가적인 논의 사항
  - 중간 경유지 설정 기능
  - 여러 목적지 입력 시 추천 경로 순서
  - 

---
# 4장 - 분산 메시지 큐


## 1단계 - 문제 이해 및 설계 범위 확정


## 2단계 - 개략적 설계안 제시 및 동의 구하기


## 3단계 - 상세 설계


## 4단계 - 마무리

