# Mock vs Fake
## 주제 선정 이유?
어느 면접에서 들었던 질문이다.

"Mock과 Fake의 차이점은 무엇인가요?"

듣고 나서 정확하게 답변하기 힘들었다.
이 질문을 받은 당시 면접관분께 양해를 구하고 잠시 생각할 시간을 가졌다.
그런데, 아무리 생각해도 Mock과 Fake의 명확한 차이가 떠오르지 않았다

1. 그나마 생각나는 건 내가 직접 구현한 Fake 객체를 사용할 땐 Fake라고 불렀던 것.
   - 외부 의존성이 있는 객체를 원하는 결과값을 리턴하도록 Fake로 구현한 것이었다.
     - 결제 구현 시 PG사의 API를 통해 결제 성공/실패 등의 결과를 받아야 했고 이를 테스트하기 위해 Fake로 구현했다.
2. 그리고 단위 테스트할 때 Mock 프레임워크를 통해 만든 객체는 Mock이라고 불렀던 것.
정도가 떠올랐고 이렇게 답변을 했었다.

답변하면서도 뭔가 모호한 느낌이 들었고, Mock과 Fake의 차이를 명확하게 모르는 상태인 것같다고 말씀드렸다.
이번에 질문을 받았으니, 다음에는 모르면 안되니까 정확하게 알고자 공부를 하게 됐다.

## Mock
### 영단어

1. 동사 (특히 흉내를 내며) 놀리다[조롱하다] (=make fun of)
2. 동사 무시[경시]하다
3. 형용사 거짓된, 가짜의 (=sham)
4. 형용사 모의의

[출처 : 네이버 사전](https://dict.naver.com/dict.search?dicQuery=mock&query=mock&target=dic&ie=utf8&query_utf&isOnlyViewEE)

### 필요성
- 테스트 작성 시 환경 구축이 어려운 경우
- 테스트 시간이 오래 걸릴 경우

크게 위 두 가지 경우에 Mocking이 필요하다고 본다.
환경 구축이 어려운 상황이란 아직 구축되지 않은 모듈인 경우, DB와 같이 작업 시간이 오래 걸리는 경우 등과 같은 상황이다.

테스트 시간이 오래 걸린다는 경우는 말 그대로 DB I/O와 같은 지연 시간으로 인해 테스트가 오래 동작할 경우를 의미한다.

### 테스트 더블
테스트 진행이 어려울 때 대신해서 진행하도록 만들어주는 객체다.
테스트 더블은 아래 나오는 더미, 스텁, 페이크, 스파이, 목을 포함하는 상위의 개념이다.

### 더미 객체
단순하게 인스턴스화할 수 있는 수준의 객체를 구현하는 것이다.
객체 기능을 사용하지 않고 객체 자체만으로 테스트를 진행할 수 있을 때 사용한다고 한다.

### 테스트 스텁
더미보다 좀 더 구현된 객체로 더미 객체가 실제 동작하는 것처럼 보이게 만드는 것이다.
객체의 특정 상태를 가정해서 만들기에 특정 값을 리턴하거나 출력하는 작업 등을 수행하는 데 사용된다.

### Fake 객체
여러 상태를 대표할 수 있도록 '**구현**'된 객체다.
실제 로직이 구현된 것처럼 보이게 한다.
페이크 객체를 만드는 게 오래 걸릴 경우 적당한 수준에서 구현하거나 Mock 프레임워크를 사용한다고 한다.

### 테스트 스파이
테스트에서 사용되는 객체로 메소드의 사용 여부나 정상 호출 여부 등을 기록하고 요청 시 알려준다.
행위 기반 테스트가 필요한 경우 사용된다고 한다(특정 메서드 호출하면 다른 메서드가 실행되어야 하는 경우 등)
특수한 경우를 제외하곤 잘 쓰지 않고 Mock 프레임워크에서 기본적으로 제공하는 경우가 많다.

## Fake vs Mock
Fake는 실제로 유사하게 동작을 간이로 구현한 구현체이다.
그래서 기능을 대체해서 테스트가 가능하고, 내부에 로직이 존재한다.
즉, 결과를 기반으로 한 테스트라는 의미이다.

Mock은 행위를 검증하기 위해 사용되는 객체이다.
Mock은 특정 행위를 지정하고, 테스트 과정에서 그 행동이 의도대로 이루어졌는지를 검증하는 데 초점이 맞춰져 있다.
로직이 없고, 특정 메서드가 호출됐는지 확인하는 등의 역할을 한다.
보통 Mock 프레임워크를 통해 생성해서 사용하는 경우가 많을 것이다.
```kotlin
class MockPaymentProcessor : PaymentProcessor {
    var processCalled = false
    var lastAmount = 0

    override fun process(amount: Int): String {
        processCalled = true
        lastAmount = amount
        return "결제 성공" // 실제 로직 없음
    }
}
```

## Fake vs Stub
Fake는 **객체의 행동을 흉내내는 것**이 핵심이다.
원본 객체가 하는 행동을 Fake 객체가 흉내내기 때문에 여러 케이스에 대해서 자세하게 처리를 해둬야 한다.
```kotlin
class FakePaymentProcessor() {
    fun processPayment(amount: Int): String {
        return when {
            (amount <= 0) -> "결제 실패: 유효하지 않은 금액"
            amount > getBalance() -> "결제 실패: 잔액 부족"
            else -> {
                getBalance() -= amount
                "결제 성공"
            }
        }
    }
}
```

스텁은 최대한 단순하게 대체하는 것이 핵심이다.
어떤 값을 반환하는 메서드일 경우 단순하게 리턴문만 하드코딩해 반환하기도 한다는 것이다.

```kotlin
class Stub{
    fun getPaymentResult(): String {
        return "결제 성공"
    }
}

```

그렇기 때문에 페이크와 스텁의 차이는 상세하게 구현되어 있는지, 단순하게 결과값만 나오는지 등에 있다고 볼 수 있다.
성공/실패같이 응답만 필요한 경우 스텁을 사용할 수 있다.
스텁은 특정 값을 하드코딩하기 때문에 테스트 케이스마다 스텁을 계속해서 바꿔야하는 상황이 발생할 수 있다.
 -> 테스트 케이스마다 스텁을 만들게 될 수도...

'잔액 부족일 경우 실패', '결제 금액과 요청 금액이 맞지 않을 경우 실패' 등과 같이 로직이 들어있고, 이에 대한 결과가 각각 필요하여 구현했을 때에는 Fake라고 볼 수 있다.
Fake는 스텁에 비해서 더 진짜 객체처럼 동작을 흉내냈기 때문에 실제 객체를 대신해서 Fake 객체 하나만 써도 될 수 있다.

