# 1장 - 근접성 서비스
- 근접성 서비스는 현재 위치에서 가까운 시설을 찾는 데 이용

## 1단계 - 문제 이해 및 설계 범위 확정
- 설계 범위 줄이기
  - Q) 사용자가 검색 범위를 지정할 수 있어야 하는가? 반경 내 표시할 사업장이 충분하지 않을 경우 시스템이 알아서 확장해도 되는가?
    - A) 일단 주어진 반경 내의 사업장만 대상으로 함. 시간이 남으면 이후 처리를 고려
  - Q) 최대 반경은? 20km로 해도 되는가?
    - A) ok
  - Q) 사용자가 UI에서 검색 반경을 변경할 수 있는가?
    - A) 네. 0.5km, 1km, 2km, 5km, 20km 중 선택 가능
  - Q) 사업장 정보는 어떻게 시스템에 추가/삭제/갱신 되는가? 사업장에 대한 작업 정보가 실시간으로 유저에게 보여야 하는가?
    - A) 소유주가 정보를 추가/삭제/갱신 할 수 있어야 함. 새로 추가되거나 갱신한 정보는 다음 날까지 반영됨
  - Q) 사용자가 이동 중 앱이나 웹사이트 이용 시 항상 현재 위치 기준을 유지하기 위해 자동 갱신해야 하는가?
    - A) 사용자 이동 속도가 그리 빠르지 않아서 상시 갱신은 필요 없다고 가정
- 기능 요구사항
  - 사용자의 위치(경도와 위도 쌍)와 검색 반경 정보에 매치되는 사업장 목록 반환
  - 소유주가 사업장 정보를 추가/삭제/갱신할 수 있도록 하되, 그 정보가 실시간 반영은 아니어도 된다
  - 고객은 사업장의 상세 정보를 볼 수 있어야 함
- 비기능 요구 사항
  - 낮은 응답 지연
  - 데이터 보호
    - 위치 기반 서비스(LBS, Location-Based Service)는 사용자의 위치 정보를 다루므로 데이터 보호가 중요
    - GDPR(General Data Protection Regulation)
    - CCPA(California Consumer Privacy Act)
  - 고가용성, 규모 확장성

### 개략적 규모 추정
- DAU 1억명
- 등록된 사업장 수 2억
- QPS : 5000
  - 하루 평균 5회 검색한다고 가정
  - 하루를 10만초로 가정
  - 1억 * 5 / 10만 = 5000

## 2단계 - 개략적 설계안 제시 및 동의 구하기
### API 설계
- GET /v1/search/nearby
  - 특정 검색 기준에 맞는 사업장 목록을 반환
  - 보통 페이지 단위로 나눠 반환
  - 요청
    - `latitude` : 사용자의 위도
    - `longitude` : 사용자의 경도
    - `radius` : 검색 반경
    - 응답
      ```json 
        {
          "total": 10,
          "businesses": [{business object}]
        }
      ```
      - business object에는 사업장 상세 정보들이 담긴다

### 데이터 모델 - 읽기/쓰기 비율 
- 읽기 연산이 매우 자주 수행됨.
  - 주변 사업장 검색
  - 사업장 정보 확인
- 쓰기 연산의 빈도는 적음.
- 읽기 연산이 압도적일 결우 RDB가 유리할 수 있다.
      
### 개략적 설계안
- 로드밸런서
  - 유입 트래픽을 자동으로 여러 서비스에 분산
  - 로드밸런서를 단일 DNS 진입점(entry point)로 지정하고, URL 경로를 분석해 어느 서비스에 트래픽을 전달할지 결정
- 위치 기반 서비스(LBS)
  - LBS는 시스템의 핵심 부분
  - 주어진 위치와 반경 정보를 이용해 주변 사업장을 검색
  - 특징
    - 쓰기 요청이 없는, 읽기 요청만 빈번하게 발생
    - QPS가 높음.
      - 특정 시간대의 인구 밀집 지역일수록 심함
    - 무상태 서비스라서 수평적 규모 확장이 쉬움
- 사업장 서비스
  - 사업장 소유주가 사업장 정보를 생성, 갱신, 삭제함.
  - 기본적으로 쓰기 요청으로 QPS가 낮음
  - 고객이 사업장 정보를 조회.
    - 특정 시간대에 QPS가 높아짐
- DB 클러스터
  - primary-secondary DB 형태로 구성할 수 있음.
  - 주 DB는 쓰기 요청을 처리, 부 DB는 읽기 요청을 처리
  - 복제에 걸리는 시간(delay) 때문에 주 DB와 부 DB의 데이터에 차이가 있을 수 있음.
    - 사업장 정보가 실시간으로 갱신될 필요가 없어서 보통 문제되지 않음.
- 사업장 서비스와 LBS의 규모 확장성
  - 둘 다 무상태 서비스이므로 확장과 축소가 쉬움

### 주변 사업장 검색 알고리즘
- Redis의 지오해시(Geohash)나 PostGIS 확장을 설치한 Postgres DB를 활용함
- 내부 구조는 어려우니 몰라도 될 수 있음.
- DB의 이름 나열보다는 지리적 위치 색인이 어떻게 동작하는지 설명해 문제 풀이 능력과 기술 지식을 강초하는 것이 좋음.

### 주변 사업장 검색 알고리즘 방안 1 - 2차원 검색
- 주어진 반경으로 그린 원 안에 놓인 사업장을 검색하는 방법
- 가장 직관적이지만, 지나치게 단순하다는 문제가 있음
- SQL 문
  - SELECT * FROM businesses WHERE (latitude BETWEEN {:my_lat} - radius AND {:my_lat} + radius) AND (longitude BETWEEN {:my_long} - radius AND {:my_long} + radius)
  - 전체 테이블을 읽으므로 비효율적
- 위도 경도 칼럼에 색인 사용
  - 위도와 경도 각각에 해당하는 데이터 집합은 금방 추출 가능
  - 두 집합의 교집합을 구할 때 효율적이지 않음.
- **DB 색인은 한 차원의 검색 속도만 개선**
- 지리적 정보를 색인하는 방법
  - 해시 기반
    - 균등 격자(even grid), 지오해시(geohash), 카르테시안 계층(cartiesian tiers) 등
  - 트리 기반
    - 쿼드트리(quadtrees), 구글 S2, R-트리(R-trees) 등
  - 각 구현 방법은 서로 다르지만, 개략적 아이디어는 동일함
    - **지도를 작은 영역으로 분할하고 고속 검색이 가능하도록 색인을 만듦**
    - 지오해시, 쿼드트리, 구글 S2가 실제로 많이 사용됨

### 주변 사업장 검색 알고리즘 방안 2 - 균등 격자
- 지도를 격자 또는 구획으로 나누는 단순한 접근법
- 사업장의 분포가 균등하지 않다는 문제가 있음
- 이상적으로는 인구 밀집 지역에는 작은 격자를, 드문 지역에는 큰 격자를 사용하면 좋음
- 인접 격자를 찾기 까다로울 수 있음

### 주변 사업장 검색 알고리즘 방안 3 - 지오해시(Geohash)
- 2차원의 위도 경도 데이터를 1차원의 문자열로 변환
- 비트를 하나씩 늘려 재귀적으로 세계를 더 작은 격자로 분할해 나감
- 자오선과 적도선을 기준으로 사분면을 나눔
  - 그 각각의 격자를 다시 사분면으로 나눔
  - 이런 식으로 계속 나눠나가면서 격자를 만듦
  - 이 절차를 원하는 정밀도까지 반복
  - 통상적으로 base32 표현법을 사용
- 지오해시는 12단계 정밀도를 가짐
- 보통 4 ~ 6단계 사이를 사용
- 최적 정밀도
  - 사용자가 지정한 반경으로 그린 원을 덮는 최소 크기 격자를 만드는 지오해시 길이를 구함
  - 격자 가장자리 처리 방식에 대한 경계 조건이 있음
- **격자 가장자리 관련 이슈**
  - 해시값의 공통 접두어(prefix)가 긴 격자들이 서로 더 가깝게 놓이게 보장함
  - 이슈 1
    - 하지만, 가깝다고 같은 접두어는 아닐 수 있음.
    - 적도의 다른 쪽에 놓이거나 자오선상으로 다른 곳에 위치할 경우임.
    - 단순한 SQL 문으로는 모든 사업장을 못 가져옴
    - SELECT * FROM geohash_index WHERE geohash LIKE 'prefix%'
  - 이슈 2
    - 공통 접두어는 유사하지만 서로 다른 격자에 놓이는 경우
    - 가장 간단하게는 현재 격자를 비롯한 모든 인근 격자의 정보를 가져옴.
- 표시할 사업장이 충분하지 않을 경우
  - 선택지 1 : 주어진 반경 내 사업장만 반환
    - 사용자가 만족하지 못할 수 있음
  - 선택지 2 : 검색 반경을 키움
    - 지오해시 값의 마지막 비트를 삭제해 검색 반경을 늘림
    - 충분한 사업장이 확보될 때까지 확대함


### 주변 사업장 검색 알고리즘 방안 4 - 쿼드트리
- 격자의 내용이 특정 기준을 만족할 때까지 2차원 공간을 재귀적으로 사분면 분할하는 데 흔히 사용되는 자료 구조
- 쿼드트리는 질의에 사용될 트리 구조를 메모리 안에 만드는 것임
- 해당 자료 구조는 각각의 LBS 서버에 존재해야 하고, 서버가 시작하는 시점에 구축됨
```java
public void buildQuadtree(TreeNode node) {
    if (countNumberOfBusinessesInCurrentGrid(node) > 100){
        node.subdivide();
        for (TreeNode child : node.getChildren()) {
            buildQuadtree(child);
        }
    }
}
```
- 쿼드트리를 전부 저장하는 데 사용되는 메모리
  - 123
  - 말단 노드
    - 격자 식별에 사용되는 좌상단과 우하단 꼭짓점 좌표 : 32바이트
    - 격자 내부 사업장 ID 목록 : ID당 8바이트 * 100
    - 총 832바이트
  - 내부 노드
    - 격자 식별에 사용되는 좌상단과 우하단 꼭짓점 좌표 : 32바이트
    - 하위 노드 4개를 가리킬 포인터 : 32바이트
    - 총 64바이트
  - 격자 안 최대 100개의 사업장이라고 가정
  - 말단 노드
    - 약 200m / 100 = 약 2m(200만)
  - 내부 노드
    - 2m * 1/3 = 약 0.67m(67만)
  - 총 메모리 요구량
    - (200만 * 832바이트) + (67만 * 64바이트) = 1.66GB + 0.43GB = 약 1.71GB
  - 1.7기가의 쿼드트리 메모리 요구량을 감안하면 충분히 서버에 올릴 수 있음
- 쿼드트리 구축 소요 시간
  - 시간 복잡도는 nlogn 이므로 몇 분 정도의 시간이 소요됨.
- 쿼드트리로 주변 사업장 검색
  - 쿼드트리 인덱스가 메모리에 구축됨
  - 검색 시작점이 포함된 말단 노드를 만날 때까지 탐색 진행
  - 해당 노드에 100개의 사업장이 있으면 해당 노드만 반환
  - 그렇지 못할 경우에만 충분한 사업장 수가 확보될 때까지 인접 노드 추가
- 쿼드트리 운영 시 고려 사항
  - 200m 개의 사업장에 대한 쿼드트리 구축 시 서버 시작 시간이 길어질 수 있음.
    - 무중단 배포가 필요해질 수 있음.
  - 사업장 추가/제거 시 쿼드트리 갱신 문제
    - 한 번에 모든 서버를 갱신하면 DB에 부하가 심해질 수 있음
    - 점진적인 갱신으로 해결 가능
    - 수많은 key가 한 번에 무효화되어 캐시 서버에 부하가 가해질 수 있음
    - 실시간 갱신 -> 락 등을 사용해야해서 설계가 복잡해짐

### 주변 사업장 검색 알고리즘 방안 5 - 구글 S2
- 구글 S2 기하(geometry) 라이브러리는 많이 사용되는 라이브러리임
- 메모리 기반(in memory)
  - 지구를 힐베르트 곡선이라는 공간 채움 곡선을 이용해 1차원 색인화하는 방안
  - **힐베르트 곡선에서는 인접한 두 지점은 색인화 후 1차원 공간에서도 인접한 위치를 보장**
- 임의 지역에 다양한 수준의 영역 지정이 가능
- 전 세계 지리적 영역에 설정한 가상의 경계
- 영역 지정도 가능함.
  - 고정된 정밀도를 사용하는 대신 최소 수준, 최고 수준, 최대 셀 개수 등 지정 가능

### 지오해시 vs 쿼드트리
- 지오해시
  - 구현과 사용이 쉬움(트리 구축이 없음)
  - 지정 반경 이내 사업장 검색을 지원
  - 정밀도 고정 시 격자 크기도 고정
  - 동적으로 격자 크기 조절은 어려움
  - 색인 갱신이 쉬움
    - 삭제 시 단순하게 열 하나만 삭제하면 됨
- 쿼드트리
  - 구현이 더 까다로움(트리 구축 필요)
  - k번째로 가까운 사업장까지의 목록을 구할 수 있음
    - 사용자는 반경에 상관 없이 가까운 사업장 k개를 찾기 원할 수도 있음
    - k개의 사업장을 찾을 때까지 검색 범위를 자동으로 조절할 수 있음
  - 인구 밀도에 따라 격자 크기를 동적으로 조정할 수 있음
  - 지오해시보다 색인 갱신이 까다로움
    - 색인 삭제 시 루트 노드부터 말단 노드까지 순회해야 함
    - 색인 갱신의 시간 복잡도는 logn
  - 다중 스레드 사용 시 락을 사용해야할 수 있음
  - 트리 균형을 다시 맞추는 리밸런싱(rebalancing)이 필요하면 더 복잡해짐

  
## 3단계 - 상세 설계
### DB 규모 확장
- 사업장 테이블
  - 사업장 정보는 한 서버에 담을 수 없을 수 있음.
  - 샤딩하기에 적합한 테이블임.
  - 샤딩하는 가장 간단한 방법은 사업장 ID를 기준으로 하는 것임.
    - 모든 샤드에 부하를 고르게 분산할 수 있을 뿐 아니라 운영 측면에서도 관리하기 쉬움
- 지리 정보 색인 테이블
  - 지오해시 테이블 구성 방법 1
    - 각 지오해시에 연결되는 모든 사업장 ID를 JSON 배열로 같은 열에 저장하는 방법
    - 특정 지오해시에 속하는 모든 사업장 ID가 한 열에 보관
  - 지오해시 테이블 구성 방법 2
    - 같은 지오해시에 속한 사업장 ID 각각을 별도 열로 저장
      - 사업장 하나에 한 레코드
  - 방법 1 JSON 배열로 저장 시 정보 갱신에서 불리함
    - JSON 배열에서 중복되는지 여부 검사도 해야하고, 병렬 실행에서 갱신 연산으로 인한 데이터 손실을 막기 위해 락을 사용해야함.
  - 색인 전부를 DB 한 대에서 모두 보관 가능함
  - 지오해시는 샤딩하기 쉽지 않으므로 섣부르게 샤딩하지 않는 게 좋을 수 있음

### 캐시
- 캐시 도입 전 정말 필요한지에 대한 의문부터 해결해야 함
- 처리 부하가 읽기 중심이고, DB 크기가 작아서 하나의 DB로 수용 가능함.
- 이런 경우 질의문 처리 성능은 I/O에 좌우되지 않으므로 메모리 캐시를 사용할 때와 비슷함
- 읽기 성능이 병목이라면 사본 DB를 증설해서 읽기 대역폭을 늘릴 수 있음
- 캐시 키
  - 사용자 위치의 위도 경보 정보
    - 사용자 전화기에서 반환되는 위치 정보는 추정치일 뿐 아주 정확하지 않고, 매 측정마다 조금씩 달라짐
    - 사용자가 이동하면 위도와 경도 정보도 미세하게 변경됨.
    - 따라서 캐시 키로 적합하지 않음.
- 캐시 데이터 유형
  - 지오해시 - 해당 격자 내의 사업장 ID 목록
    - 사업장 정보는 자주 변경되지 않음.
    - 지오해시에 대응하는 사업장 목록을 요청받으면 캐시를 우선 조회 후 없을 경우 DB에서 가져온 다음 캐시에 저장
    - 사업장 추가/수정/삭제 시 DB 갱신하고 캐시에 보관된 항목은 무효화해야함.
```java
public List<String> getNearbyBusinessIds(String geohash) {
    String cacheKey = hash(geohash);  
    List<String> listOfBusinessIds = cache.get(geohash);
    if (listOfBusinessIds == null) {
        businessIds = db.getNearbyBusinessIds(geohash);
        cache.put(geohash, listOfBusinessIds, "1d");
    }
    return listOfBusinessIds;
}
```
  - 사업장 ID - 사업장 정보 객체

### 지역(region) 및 가용성 구역
### 시간대 또는 사업장 유형에 따른 검색

### 추가 질문 : 시간대 혹은 사업장 유형별 검색
- 지금 영업 중인 사업장 혹은 식당 정보만 받아오고 싶을 경우
  - 앞서 나온 지오해시나 쿼드트리 같은 방법을 사용후 에 검색 결과로 나온 사업장 수는 상대적으로 적음
  - 사업장 ID를 전부 확보한 이후 사업장 정보를 전부 추출해서 필터링을 사용

### 최종 아키텍처 다이어그램
- 주변 사업장 검색 - 주변 반경 500미터 이내 모든 식당 찾기
  - 클라이언트 앱은 사용자 위치와 검색 반경을 로드밸런서로 전송
  - 로드밸런서는 해당 요청을 LBS로 보냄
  - 사용자 위치와 반경을 바탕으로 LBS는 검색 요건을 만족하는 지오해시 길이를 계산
  - LBS는 인접한 지오해시를 계산한 다음 목록에 추가
  - 각 지오해시에 대한 사업장 ID 레디스 캐시를 조회
  - 사업장 ID를 사용해 사업장 정보 레디스 캐시를 조회
  - 상세 정보에 의거해 사용자와의 거리를 계산하고 우선순위를 매긴 후 클라이언트에게 반환
- 사업장 정보 조회, 갱신, 추가, 삭제
  - 모든 사업장 정보 관련 API는 LBS와는 분리되어 있음.
  - 사업장 정보가 캐시에 기록되어 있는지 살펴봄.
  - 캐시에 없을 경우에는 DB 조회 후 캐시에 저장하고 반환
  - 새로 추가하거나 갱신 정보는 비실시간일 경우에는 트래픽이 적은 시간에 작업을 진행


## 4단계 - 마무리


### 추가 해 볼 내용
- 직접 지도 데이터 이용해서 테스트해보기
- 각 방안에 대해서도 실습해보기

---
# 2장 - 주변 친구
- 1장의 근접성 서비스와의 차이는 사업장 주소는 정적이지만, 주변 친구의 위치는 동적이라는 점이다.

## 1단계 - 문제 이해 및 설계 범위 확정
- 질의응답
  - Q) 지리적으로 얼마나 가까워야 '주변에 있다'고 하는가?
    - A) 5마일, 수치는 설정 가능함
  - Q) 그 거리가 두 사용자 사이의 직선거리로 가능하는가?
    - A) 넹
  - Q) 얼마나 많은 사용자가 해당 앱을 사용하는가? 10억명에 10% 정도가 해당 기능을 사용한다고 가정해도 되는가?
    - A) 넹
  - Q) 사용자의 이동 이력을 보관해 두는가?
    - A) 넹
  - Q) 친구 관계에 있는 사용자가 10분 이상 비활성 상태면 해당 사용자가 사라지는가, 아니면 마지막 위치를 표시하는가?
    - A) 사라지게 함
  - Q) GDPR(General Data Protection Regulation)이나 CCPA(California Consumer Privacy Act)와 같은 규정을 준수하는가?
    - A) 일단은 생략함
- 기능 요구 사항
  - 사용자는 모바일 앱에서 주변 친구를 확인할 수 있어야 함.
  - 각 친구와의 거리와 마지막 갱신 시각을 함께 표시
- 비기능 요구 사항
  - 낮은 지연 시간
  - 안정성
  - 결과적 일관성
    - 위치 데이터에 강한 일관성까지는 필요 없음. 어느정도 시간이 걸리는 것도 용인함

### 개략적 규모 추정
- 주변 친구는 5마일(8km) 반경 이내 친구로 정의
- 위치 정보는 30초 주기로 갱신
- 주변 친구 검색 기능을 활용하는 사용자는 1억명으로 가정
- 동접자수는 DAU의 10%, 1천만명으로 가정
- 평균적으로 한 사용자는 400명의 친구를 갖는다고 가정, 모든 사용자가 주변 친구 검색 기능을 활용한다고 가정
- 페이지 당 20명의 주변 친구를 표시하고, 사용자 요청이 있으면 더 많은 친구를 표시
- QPS : 약 334_000
  - DAU 1억
  - 동시 접속 1천만
  - 30초마다 자기 위치를 시스템에 전송
  - 1천만 / 30초 = 334_000

## 2단계 - 개략적 설계안 제시 및 동의 구하기
### 개략적 설계안
- P2P를 활용한 방시긍로도 해결 가능함.
  - 모바일 단말은 연결 상태가 좋지 않을 수도 있고, 사용할 수 있는 전력이 충분하지 않아서 실용적인 아이디어는 아님
- 공용 백엔드를 사용하면 좀 더 실용적으로 처리 가능
  - 공용 백엔드의 역할
    - 모든 활성 상태 사용자의 위치 정보를 수신
    - 위치 변경 내역 수신 시 마다 사용자의 모든 활성 상태 친구를 찾아 해당 단말로 변경 내용을 전달
    - 두 사용자 사이 거리가 임계치보다 멀면 변경 내용 전송X
    - 큰 규모에서는 적용하지 쉽지 않음.
      - 30초 마다 갱신 -> 초당 334_000번의 위치 정보 갱신
      - 400명의 친구, 10% 활성 상태일 경우 초당 334_000 * 400 * 0.1 = 13_360_000번의 메시지 전송

### API 설계

### 데이터 모델


## 3단계 - 상세 설계

## 4단계 - 마무리
---
# 3장 - 구글 맵
## 1단계 - 문제 이해 및 설계 범위 확정

## 2단계 - 개략적 설계안 제시 및 동의 구하기

## 3단계 - 상세 설계

## 4단계 - 마무리