# 7장 - 분산 시스템을 위한 유일 ID 생성기 설계

## auto_increment
- 분산 환경에서는 AI를 사용할 수 없음.
- 여러 DB 사용 시 지연 시간을 낮추기가 무척 힘들어짐.

### Q) 분산 환경에서 AI가 여러 DB 사용 시 지연 시간을 낮추기 힘든 이유가 무엇인가?

## 1단계 - 문제 이해 및 설계 범위 확정
- 면접의 첫 단계는 적절한 질문을 통해 모호함을 없애야 함.
  - Q) ID의 특성은?
    - A) 유일해야하고, 정렬 가능해야 함.
  - Q) 새로운 레코드의 ID는 항상 1만큼 커야하는가?
    - A) 시간 흐름에 따라 커지지만, 언제나 1 증가한다고 보장은 못 함.
  - Q) ID는 숫자로만 이루어지는가?
    - A) 넹
  - Q) 시스템 규모는 어느정도인가?
    - A) 초당 10_000 ID를 생성할 수 있어야 함.
- 요구사항
  - ID는 유일해야 함.
  - 숫자로만 구성돼야 함
  - 64비트로 표현될 수 있어야 함
  - 발급 날짜에 따라 정렬 가능해야 함
  - 초당 10_000개의 ID를 만들 수 있어야 함

## 2단계 - 개략적 설계안 제시 및 동의 구하기
- 유일성 보장하는 방법
  - 다중 마스터 복제(multi-master replication)
  - UUID(Universally Unique Identifier)
  - 티켓 서버(ticket server)
  - 트위터 스노플레이크(twitter snowflake) 접근법

### 다중 마스터 복제(multi-master replication)
- DB의 auto_increment 기능을 활용하는 것
  - ID 값을 1이 아니라 DB 개수 K 만큼 증가 시킴
- DB 수에 따라 초당 생산 가능 ID 수가 증가함
- 단점
  - 여러 데이터 센터에 걸쳐 규모를 늘리기 어려움
  - ID 유일성은 보장되지만, 시간 흐름에 맞춰 커지는 걸 보장할 수 없다.
  - 서버 추가/제거 시 잘 동작하게 하기 어렵다.

### Q) 시간 흐름에 맞춰 커지는 걸 보장할 수 없는 이유가 무엇인가?

### UUID(Universally Unique Identifier)
- 128비트의 수
- 충돌 가능성이 매우 낮음
  - 중복 UUID가 1개 생길 확률이 50%가 되기 위해서는 초당 10억 개의 UUID를 100년 동안 만들어야 함
- 각 웹 서버가 별도의 ID 생성기를 사용해 독립적으로 ID를 만듦
- 장점
  - 만드는 것은 단순함.
  - 서버 사이 조율이 필요 없어서 동기화 이슈가 없음
  - 각 서버가 자기가 쓸 ID를 직접 만들기 때문에 규모 확장도 쉬움
- 단점
  - 128비트로 길다.
    - 이번 요구 사항은 64비트임.
  - ID를 시간 순으로 정렬할 수 없다
  - ID에 숫자가 아닌 값이 들어올 수 있다.

### 티켓 서버(ticket server)
- 중앙 집중형 티켓 서버 사용
  - auto_increment 기능을 갖춘 티켓 서버를 사용
- 장점
  - 유일성이 보장되는 숫자로만 구성된 ID를 만들기 쉽다.
  - 구현이 쉽고 중소 규모 애플리케이션에서 적합하다.
- 단점
  - 티켓 서버가 SPOF(Single-Point-of-Failure)가 된다.
    - 이를 피하기 위해서는 티켓 서버를 여러 대 사용하면 된다.
      - 데이터 동기화와 같은 새로운 문제가 생길 수 있다.

### 트위터 스노플레이크(twitter snowflake) 접근법
- 트위터에서 사용
- ID의 구조를 여러 절로 분할
  - 사인 비트
    - 현재 사용하지 않지만, 나중을 위해 유보해둔 1비트
  - 타임스탬프
    - 41비트
    - 기원 시각(epoch) 이후로 몇 밀리초 경과했는 지
  - 데이터센터 ID
    - 5비트
    - 32개 데이터센터 사용 가능
  - 서버 ID
    - 5비트
    - 데이터센터 당 32개의 서버 사용 가능
  - 일련 번호
    - 12비트
    - 각 서버에서 ID 생성 마다 일련 번호를 1만큼 증가
    - 1 밀리초 경과 시 마다 0으로 초기화

## 3단계 - 상세 설계
- 데이터 센터 ID와 서버 ID는 시스템 시작 시 결정됨
  - 일반적으로 시스템 운영 중에는 바뀌지 않음.
  - 테이터 센터 ID나 서버 ID를 잘 못 변경하면 ID 충돌이 발생할 수 있음.
- 타임스탬프나 일련번호는 ID 생성기가 동작 중 만들어지는 값

### 타임 스탬프
- 가장 중요한 41비트를 차지함
- 시간 흐름에 따라 정렬 가능
- 이진 표현 형태로부터 UTC 시각을 추출
- 41비트로는 약 69년을 표현할 수 있다.
- 69년이 지난 후에는 기원 시각을 바꾸거나 ID 체계를 마이그레이션 해야함.

### 일련번호
- 12비트
  - 4096개의 값을 가질 수 있음
- 같은 밀리초 동안 하나 이상의 ID를 만든 경우에만 0보다 큰 값을 갖게 됨

## 4단계 - 마무리
- 추가적인 논의 사항
  - 시계 동기화
    - ID가 모두 같은 시계를 사용한다고 가정함.
    - 실제로는 하나의 서버가 여러 코어에서 실행 시 유효하지 않음.
    - 물리적으로 독립된 여러 장비에서 실행 시에도 유효하지 않음.
    - NTP(Network Time Protocol)이 가장 보편적인 수단임.
  - 각 절(section)의 길이 최적화
    - 동시성이 낮고 수명이 긴 애플리케이션인 경우 등과 같은 상황에 대해 처리해야함.
      - 이런 경우 일련 번호를 줄이고 타임스탬프를 늘리는 것이 효과적.
  - 고가용성
    - ID 생성기는 필수 불가결(mission critical) 컴포넌트이므로 아주 높은 가용성을 제공해야 함.
---
# 8장 - URL 간축기 설계

## 1단계 - 문제 이해 및 설계 범위 확정
- 모호함을 줄이고 요구 사항 이끌어 내기
  - Q) URL 단축기가 어떻게 동작해야하는지 예제를 보여줘
    - A) https://www.naver.com/q=asdasd&c=asdasd&v=asdasd 와 같은 입력이 있을 때, https://tinyurl.com/abc1234 와 같은 형태로 변환해야 함.
  - Q) 트래픽 규모는?
    - A) 매일 1억(100million) 개의 URL을 단축해야 함.
  - Q) 단축 URL의 길이는 어느 정도여야 하는가?
    - A) 짧으면 짧을 수록 좋다.
  - Q) 단축 URL에 포함될 문자에 제한이 있는가?
    - A) 단축 URL에는 숫자(0부터 9까지)와 영문자(a부터 z, A부터 Z까지)만 사용 가능
  - Q) 단축 URL을 시스템에서 지우거나 갱신할 수 있는가?
    - A) 시스템을 단순화하기 위해 삭제하거나 갱신 할 수 없다고 가정
- 시스템의 기본적인 기능
  - URL 단축
    - 주어진 긴 URL을 짧게 줄인다
  - URL 리디렉션(redirection)
    - 단축된 URL로 HTTP 요청이 오면 원래 URL로 안내
  - 높은 가용성과 규모 확장성, 장애 감내가 요구됨

### 개략적 추정
- 쓰기 연산
  - 매일 1억 개의 단축 URL 생성
- 초당 쓰기 연산
  - 1억/24/3600 = 1160
- URL 단축 서비스를 10년간 운영한다고 가정하면 1억 * 365 * 10 = 3650억 개의 레코드를 보관해야 함
- 축약 전 URL의 평균 길이는 100이라고 하면
  - 10년 동안 필요한 저장 공간은 3650억 * 100바이트 = 36.5TB

## 2단계 - 개략적 설계안 제시 및 동의 구하기
- API 엔드포인트, URL 리디렉션, URL 단축 플로우에 대해 학습

### API 엔드포인트
- 필요한 엔드포인트
  - URL 단축용 엔드포인트
    - 단축할 URL을 담아서 POST 요청
    - POST /api/v1/data/shorten
    - 인자
      - {longUrl: longURLString}
    - 반환
      - {shortUrl: shortURLString}
  - URL 리디렉션용 엔드포인트
    - 단축된 URL을 받아서 리디렉션
    - GET /api/v1/shortUrl
    - 반환
      - 원래 URL

### URL 리디렉션
- 단축 URL을 받으면 원래 URL로 바꿔서 301 응답의 Location 헤더에 담아 반환
- 301 Permanently Moved
  - 해당 URL에 대한 HTTP 요청의 처리 책임이 **영구적**으로 Location 헤더에 반환된 URL로 이전
  - 영구적으로 이전되었으므로, 브라우저는 이 응답을 **캐시**함
    - 같은 단축 URL 요청 시 브라우저는 ㅐ시된 원래 URL로 요청을 보냄
  - 서버 부하 감소
  - 트래픽 분석이 어려움
- 302 Found
  - 해당 URL에 대한 요청이 **일시적**으로 Location 헤더에 반환된 URL로 이전
  - 항상 단축 URL 서버를 거친 후 원래 URL로 리디렉션\
  - 클릭 발생률이나 발생 위치 추적에 유리
- 해시 테이블을 사용한 구현
  - <단축 URL, 원래 URL> 쌍을 저장
  - 가장 직관적
  - 원래 URL = hashTable.get(단축 URL)
  - 301 또는 302 응답 Location 헤더에 원래 URL을 넣어 전송

### URL 단축
- 긴 URL을 해시 값으로 대응 시킬 해시 함수를 찾아야 함
- 해시 함수가 만족해야 할 요구 사항
  - 입력으로 주어진 긴 URL이 다른 값이면 해시 값도 달라야 한다.
  - 계산된 해시 값은 원래 입력으로 주어졌던 긴 URL로 복원될 수 있어야 한다.

## 3단계 - 상세 설계
### 데이터 모델
- 해시 테이블의 문제점
  - 메모리는 유한하며 비싸다
- <단축 URL, 원래 URL> 쌍을 저장하는 데이터베이스를 사용

### 해시 함수
- 원래 URL을 단축 URL로 변환하는 데 사용

### 해시 값 길이
- 사용할 수 있는 문자
  - [0-9, a-z, A-Z]
  - 10 + 26 + 26 = 62개
  - 62^n >= 3650억 인 n의 최솟값을 찾아야 함
  - 62^6 = 56_800_235_584
  - 62^7 = 3_521_614_606_208
  - 62^8 = 218_340_105_584_896
  - 따라서 hashValue의 길이는 7이 적당함

### 해시 후 충돌 해소
- https://en.wikipedia.ogr/wiki/Systems_design 축약
  - CRC32
    - 5cb54054
  - MD5
    - 5a62509a84df9ee03fe1230b9df8b84e
  - SHA-1
    - 0eeae7916c06853901d9ccbefbfcaf4de57ed85b
- 가장 짧은 CRC32조차도 7자리를 넘음.
  - 해시 값에서 처음 7자만 사용
    - 충돌할 확률 증가
    - 충돌 시 충돌이 해소될 때가지 사전에 정한 문자열을 해시값에 덧붙임
    - 매번 DB 질의가 들어가야 하므로 오버헤드가 큼
    - 블룸 필터를 사용하면 성능을 높일 수 있음

### base-62 변환
- 진법 변환은 URL 단축기를 구현 시 흔히 사용되는 접근법 중 하나
- 수의 표현 방식이 다른 두 시스템이 같은 수를 공유해야하는 경우 유용함
- 62진법을 사용하는 이유는 hashValue에 사용할수 있는 문자가 62개이기 때문

### 해시 후 충돌 해소 vs base-62 변환
TODO : 여기 표 작성 

### URL 단축기 상세 설계

---
# 9장 - 웹 크롤러 설계