# 7장 - 호텔 예약 시스템

## 1단계 - 문제 이해 및 설계 범위 확정
- 설계 범위 확정
  - Q) 시스템 규모?
    - A) 5000개 호텔에서 100만 개의 객실을 갖춘 호텔 체인을 위한 웹 사이트 구현
  - Q) 대금은 예약 시인지, 호텔 도착 시인지?
    - A) 시간 제한이 있어 예약 시 전부 지불로 가정
  - Q) 웹사이트에서만 예약이 되는가, 전화 같은 것도 되는가?
    - A) 웹 사이트나 앱에서만 가능.
  - Q) 예약 취소 기능은?
    - A) 물론임
  - Q) 추가 고려 사항은?
    - A) 10% 초과 예약이 가능해야 함. 실제 객실보다 많이 판매 가능
  - Q) 시간이 제한되어 있어 검색은 제외하고자 함.
    - 호텔 정보 페이지
    - 객실 정보 페이지
    - 객실 예약 지원
    - 호텔이나 객실 정보 추가/삭제/갱신하는 관리자 페이지
    - 초과 예약 지원
    - A) 굳
    - A) 객실 가격은 유동적임. 객실 여유에 따라 유동적으로 변경되며 매일 달라짐

### 비기능 요구 사항
- 적절한 지연 시간
  - 예약 시 응답 시간이 빠르면 이상적인데, 몇 초 정도 지연은 괜찮음

### 개략적 규모 추정
- 5000개 호텔, 100만 개의 객실
- 객실의 70%가 사용 중이고, 평균 투숙 기간은 3일이라고 가정
- 일일 예약 건수 : 233_333건
  - 100만 * 0.7 / 3
- 초당 예약 건수 약 3건(TPS)
  - 240_000 / 하루
- 웹 사이트 사용 흐름
  - 호텔/객실 상세 페이지
    - 호텔/객실 정보를 확인 -> 조회
  - 예약 상세 정보 페이지
    - 사용자가 날짜, 투숙 인원, 결제 방법 등의 상세 정보 확인 -> 조회
  - 객실 예약 페이지
    - 사용자가 '예약'버튼을 눌러 객실을 예약 -> 트랜잭션 발생
- 대략 10%만 다음 단계로 진입하고 그 외에는 흐름을 이탈한다고 가정
  - 객실 상세 페이지 QPS = 300
  - 예약 상세 정보 페이지 QPS = 30
  - 객실 예약 페이지 QPS = 3

## 2단계 - 개략적 설계안 제시 및 동의 구하기
### API 설계 - 호텔 관련 API
| API                        | 설명              |
|----------------------------|-----------------|
| GET v1/hotel/{hotel_id}    | 호텔 정보 조회        |
| POST v1/hotels             | 신규 호텔 추가, 직원 전용 |
| PUT v1/hotel/{hotel_id}    | 호텔 정보 갱신, 직원 전용 |
| DELETE v1/hotel/{hotel_id} | 호텔 삭제, 직원 전용    |

### API 설계 - 객실 관련 API
| API                                      | 설명              |
|------------------------------------------|-----------------|
| GET v1/hotels/{hotel_id}/rooms/{room_id} | 객실 정보 조회        |
| POST v1/hotels/{hotel_id}/rooms          | 신규 객실 추가, 직원 전용 |
| PUT v1/hotels/{hotel_id}/rooms/{room_id} | 객실 정보 갱신, 직원 전용 |
| DELETE v1/hotels/{hotel_id}/rooms/{room_id} | 객실 삭제, 직원 전용    |

### API 설계 - 예약 관련 API
| API                                   | 설명            |
|---------------------------------------|---------------|
| GET v1/reservations | 사용자의 예약 이력 조회 |
| GET v1/reservations/{reservation_id} | 예약 정보 조회 |
| POST v1/reservations | 객실 예약 |
| DELETE v1/reservations/{reservation_id} | 예약 취소 |

### 데이터 모델
- 예약 시스템이 지원해야 할 질의
  - 호텔 상세 정보 확인
  - 지정된 날짜 범위에 사용 가능한 객실 유형 확인
  - 예약 정보 기록
  - 예약 내역 또는 과거 예약 이력 정보 조회
- RDB를 선택
  - 읽기 쓰기 빈도가 쓰기 연산에 비해 높은 흐름을 잘 지원함
    - 웹 사이트와 앱을 방문하는 사용자 수가 예약자 수에 비해 압도적으로 많음
    - NoSQL은 쓰기 연산에 최적화 되어 있음
  - ACID(원자성, 일관성, 고립성, 지속성)을 보장함
    - 예약에서 ACID는 매우 중요함
    - 이중 청구, 잔액 마이너스, 이중 예약 등 방지가 필요함
  - 비즈니스 데이터 구조를 쉽게 모델링 가능
    - 엔티티 간의 관계를 안정적으로 지원

### RDB 엔티티 설계 시 주의점
- room_id가 에어비엔비 같은 회사에는 적합하지만, 호텔에는 그렇지 않을 수 있음.
- 호텔은 특정 룸을 예약하기 보다 '특정 객실 유형'을 예약하기 때문임

### 개략적 설계안
- 사용자
  - 객실을 예약하는 당사자
- 관리자(호텔 직원)
  - 고객 환불, 예약 취소, 객실 정보 갱신 등의 관리 작업을 수행
- CDN
  - JS 코드 번들, 이미지, 동영상, HTML 등 모든 정적 콘텐츠를 캐시해 웹 사이트 로드 성능을 개선
- 공개 API 게이트웨이
  - 처리율 제한, 인증 등의 기능을 지원하는 완전 관리형 서비스
  - 엔드포인트 기반으로 특정 서비스에 요청을 전달할 수 있게 구성
- 내부 API
  - 승인된 호텔 직원만 사용 가능한 API
  - VPN 등을 이용해 외부 공격으로부터 보호함
- 호텔 서비스
  - 호텔과 객실에 대한 정보를 제공
  - 대부분 정적이라 쉽게 캐시 가능
- 요금 서비스
  - 어떤 때에 어떤 요금을 받아야 하는지 데이터를 제공하는 서비스
  - 객실 요금이 해당 날짜에 호텔에 얼마나 손님이 몰리냐에 따라 달라짐
- 예약 서비스
  - 예약 요청을 받고 객실을 예약하는 과정을 처리.
  - 객실이 예약되거나 취소될 때 잔여 객실 정보를 갱신하는 역하도 담당
- 결제 서비스
  - 고객의 결제를 맡아 처리하고, 절차가 마무리되면 예약 상태를 결제 완료로 갱신
  - 실패한 경우 승인 실패로 업데이트
- 호텔 관리 서비스
  - 승인된 호텔 지원만 사용 가능.
  - 임박한 예약 기록 확인, 고객 객실 예약, 예약 취소 등의 기능을 제공

## 3단계 - 상세 설계
### 개선된 데이터 모델
- API 인자 변경
  - 예약 API에서 호출 인자를 roomID -> roomTypeID로 변경
- 스키마 변경
  - room 스키마에서 room_type_iD를 추가
  - 예약 서비스쪽 스키마에서도 room_id -> room_type_id로 변경
  - room_type_inventory 테이블
    - 호텔의 모든 객실 유형을 담는 테이블
    - 예약 시 아주 중요함.
    - hotel_id : 호텔 식별자
    - room_type_id : 객실 유형 식별자
    - date : 일자
    - total_inventory : 총 객실 수에서 일시적으로 제외한 객실 수를 뺀 값
      - 유지 보수 등의 사유로 예약 불가능 할 수 있음
    - total_reserverd : 지정된 hotel_id, room_type_id, date에 대한 예약된 객실 수
    - 날짜당 하나의 레코드를 사용 시 날짜 범위 내에서 예약을 쉽게 관리하고 질의 가능함
    - hotel_id, room_type_id, date를 복합 키로 사용함
    - 5000개의 호텔이 있고 각 호텔에 20개의 객실 유형이 있을 경우 레코드의 수 = 7_300만 개
      - 5000 * 20 * 2년 * 365

### 동시성 문제
- 해결해야 할 문제 두 가지
  - 같은 사용자가 예약 버튼을 여러 번 누르는 경우
    - 클라
      - 클라에서 요청 전송 후 '예약'버튼 비활성화
    - 멱등(idempotent) API
      - 예약 API 요청에 멱등 키를 추가
      - 몇 번을 호출해도 같은 결과를 내는 API를 멱등 API라고 함
  - 여러 사용자가 같은 객실을 동시에 예약하는 경우

### 멱등 키
- 예약 주문서를 생성
- 고객이 검토할 수 있게 예약 주문서를 반환
  - 이때 API는 반환 결과에 멱등 키 reservation_id를 포함함
    - 전역적 유일성을 보장하는 ID 생성기가 만들어낸 키여야 함
- 검토가 끝난 예약 전송(reservation_id 포함)
- 사용자가 예약 완료 버튼 클릭 한 번 더 클릭해도 reservation_id가 이미 있으므로 새로운 레코드는 생성되지 않음.

### 잔여 객실이 하나일 때 여러 사용자가 예약하는 경우
- 트랜잭션 격리 수준이 가장 높은 serializable이 아닐 때
- 트랜잭션 A가 commit 되지 않으면 트랜잭션 B는 트랜잭션 A의 변경 사항을 모름.
- 락
  - 비관적 락
  - 낙관적 락
  - 데이터베이스 제약 조건(constraint)

### 비관적 락
- 레코드 갱신하는 순간 즉시 락을 걸어 동시 업데이트를 방지
- 해당 레코드를 갱신하려는 다른 사용자는 먼저 락을 건 사용자가 변경을 끝내고 락 해제까지 기다려야 함.
  - MySQL은 "SELECT ... FOR UPDATE" 쿼리를 사용해 레코드에 락을 검
- 장점
  - 애플리케이션이 변경 중이거나 변경이 끝난 데이터를 갱신하는 일을 막을 수 있음.
  - 구현이 쉽고 모든 갱신 연산을 직렬화해 충돌을 막음.
  - 비관적 락은 데이터에 대한 경합이 심할 때 유용함
- 단점
  - 여러 레코드에 락을 걸면 교착 상태(deadlock)가 발생할 수 있음.
    - Deadlock을 피하는 애플리케이션 코드를 짜는 것은 까다로울 수 있음
  - 확장성이 낮음.
    - 트랜잭션이 오랫동안 락을 해제하지 않으면 다른 트랜잭션은 락이 걸린 자원에 접근이 안됨.
    - 트랜잭션의 수명이 길거나 많은 엔티티에 관련된 경우 DB 성능에 심각한 영향을 줌

### 낙관적 락
- 여러 사용자가 동시에 같은 자원을 갱신하려 시도하는 것을 허용함
- 버전 번호와 타임스탬프 두 가지 방법으로 구현함
  - 서버 시계는 시간이 지남에 따라 부정확해질 수 있어서 일반적으로 버전 번호를 더 선호함
- 구현 방법
  - 테이블에 version 컬럼을 추가함
  - 레코드 수정 전 version을 읽어옴
  - 수정 시 version 번호에 1을 추가해 DB에 다시 기록함
    - 이때 유효성을 통해 다음 버전 번호는 현재 버전보다 1 큰 값이어야 함.
    - 유효성 검사가 실패되면 트랜잭션은 중단(abort)되고 2단계부터 다시 시작함.
- 비관적 락보다 일반적으로 빠름.
  - 락을 걸지 않기 때문임.
  - 다만, 동시성 수준이 높으면 성능이 급격하게 나빠짐
    - 많은 클라이언트가 동시에 예약하는 경우
    - 모든 클라이언트에서 같은 잔여 객실 수와 버전 정보를 취득함.
    - 이 중 단 하나의 클라이언트만 갱신에 성공함.
    - 실패한 모든 클라이언트는 retry를 함
    - 하지만, 매번 성공하는 클라이언트는 하나임
- 장점
  - 애플리케이션이 유효하지 않은 데이터를 편집하는 일을 막음
  - DB 자원에 락을 걸 필요가 없음
    - 버전 정보를 통해 데이터 일관성을 유지하는 책임은 애플리케이션에게 있음
  - 낙관적 락은 경쟁이 치열하지 않는 상황에 적합하고 락을 관리하는 비용 없이 트랜잭션 처리가 가능함
- 단점
  - 치열한 경쟁에서는 성능이 별로임
- 예약 QPS가 낮아 경쟁이 심하지 않을 수 있어 좋은 선택지임


### DB 제약 조건
- 낙관적 락과 유사함
- CONSTRAINT `check_room_count` CHECK (`total_inventory` >= `total_reserved`) 를 제약 조건에 추가함.
- 사용자가 유휴 객실 이상의 예약을 하게 되면 트랜잭션이 중단되고 rollback됨
- 장점
  - 구현이 쉬움
  - 경쟁이 심하지 않을 때 잘 동작함
- 단점
  - 낙관적 락과 마찬가지로 경쟁이 심하면 실패하는 연산 수가 엄청나게 늘 수 있음
  - 사용자는 객실이 있다고 판단했지만, 실제론 없다는 응답을 받을 수 있음.
  - DB 제약 조건은 애플리케이션 코드와 달라서 버전을 통제하기 어려움
  - 제약 조건을 허용하지 않는 DB도 있으므로, DB 교체 시 문제가 생길 수 잇음
- 예약 QPS가 낮아 경쟁이 심하지 않을 수 있어 좋은 선택지임

### 시스템 규모 확장
- 만약 호텔 웹 사이트만 연동되는 것이 아니라 부킹 닷컴같은 유명 예약 웹 사이트와 연동되어야 하면 어떡하는가?
- 서버는 무상태 서버라 추가하기 쉬워서 성능 문제 해결이 쉬움.
- DB는 DB 서버를 늘리는 것만으로는 성능 문제를 해결할 수 없음

### 시스템 규모 확장 - DB 샤딩
- DB를 여러 대 두고, 각 DB에 데이터의 일부를 저장하는 방법

### 캐시
- 호텔 잔여 객실 데이터는 오직 현재와 미래의 데이터만 중요함
- 데이터 보관 시 낡은 데이터는 자동 소멸되도록 TTL(Time To Live)를 설정할 수 있으면 좋음
- 이력 데이터는 다른 DB에 질의하면 됨
- Redis는 이런 상황에 적합함.
  - TTL과 LRU 캐시 교체 정책으로 메모리를 최적으로 활용 가능
- Redis를 사용하더라도 예약 시 잔여 객실을 DB에서 한 번 더 확인할 필요는 있다.
  - 최종 데이터는 결국 DB에 들어있기 때문임

### 컴포넌트 확인
- 예약 서비스
  - 잔여 객실 관리 API 제공
  - 지정된 호텔과 객실 유형, 주어진 날짜 범위에 이용 가능한 객실의 수 질의
  - 객실 예약 후 total_reserved의 값을 1 증가
  - 고객이 예약을 취소하면 잔여 객실 수를 갱신
- 잔여 객실 캐시
  - 모든 잔여 객실 관리에 필요한 질의는 Redis로 구현되는 잔여 객실 캐시로 옮겨옴
  - 잔여 객실 정보를 캐시에 미리 저장해 두어야 함
  - 키
    - hotelID_roomTypeID_{날짜}
  - 값
    - 주어진 호텔 ID, 객실 유형 ID, 날짜에 맞는 잔여 객실 수
  - 호텔 예약 시스템의 경우 잔여 객실 확인 작업으로 인해 읽기 연산 빈도가 훨씬 많고, 대부분의 읽기 연산은 캐시가 처리함.
- 잔여 객실 DB
  - 잔여 객실 수에 대한 가장 믿을 만한 정보가 보관

### 캐시가 주는 새로운 과제
- 캐시 계층 추가 시 시스템의 확장성과 처리량은 대폭 증가하지만, DB-캐시 사이 일관성 유지에 대한 새로운 문제가 생김
- 사용자가 객실 예약 시 아무 문제가 없는 경우에 새로운 두가지 작업이 이루어짐
  - 잔여 객실 수를 질의해 중분한지 확인(캐시에서 실행)
  - 잔여 객실 데이터를 갱신
    - DB가 먼저 갱신 된 후 캐시에는 비동기적으로 변경 내역 반영
    - 비동기 갱신 작업은 애플리케이션 측에서 수행할 수도 있는데, 그럴 경우 DB에 데이터 저장 후 캐시 데이터를 수정함
    - 변경 데이터 감지(CDD, Change Data Detection) 기술을 사용해 DB에 변경이 생기면 캐시를 갱신하는 방법도 있음
      - 보편적으로 많이 사용되는 솔루션으로 드베지움(Debezium)이라는 것이 있음.
      - DB에서 발생한 변경 내역을 읽는 소스 커넥터로 해서 DB 변화를 감지해 레디스 같은 캐시 시스템에 반영하도록 하는 방안
- 잔여 객실 데이터에 대한 변화를 DB에 먼저 반영해서 캐시에 최신 데이터가 없을 수 있음
  - 하지만, 이런 불일치는 DB가 최종적으로 잔여 객실을 확인하도록하면 문제가 되지 않는다고 볼 수 있음
- 장점
  - 읽기 질의를 캐시가 처리해 DB의 부하가 크게 줄어듦
  - 읽기 질의를 메모리에서 실행하므로 높은 성능을 보장 가능
- 단점
  - DB와 캐시 사이의 데이터 일관성을 유지하는 것은 어려운 문제임
    - 데이터 불일치가 사용자 경험에 어떤 영향을 끼치게 될지 신중히 따져야함

### 서비스 간 데이터 일관성
- 전통적인 모노리스 아키텍처는 데이터 일관성을 위해 RDB를 공유하는 것이 보통임
- MSA 기반의 경우 예약 서비스가 예약 및 잔여 객실 API를 모두 담당하도록 하고, 예약 테이블과 잔여 객실 테이블을 동일한 RDB에 저장하는 하이브리드 접근법을 택함
  - 이를 통해 RDB의 ACID 속성을 이용해 예약 과정에서 발생하는 많은 동시성 문제를 효과적으로 처리함
  - MSA 순수 주의자일 경우 하이브리드 접근법에 이의를 제기할 수 있음.
    - 각 마이크로 서비스가 독자적인 DB를 갖춰야하는 것으로 생각하고 있을 수 있기 때문임
    - 하지만, 이런 접근은 다양한 데이터 일관성 문제를 낳을 수 있음
    - 논리적으로 하나의 원자적 연산이 여러 DB에 걸쳐 실행되는 일을 피할 수 없게 됨
      - 하나의 트랜잭션으로 데이터 일관성을 보증하는 기법을 사용할 수 없다는 뜻임
      - 예약 갱신 연산이 실패했을 때 원래 값으로 돌려야 하지만, 데이터 불일치 문제가 발생할 수 있음
        - 2단계 커밋(2PC, 2-phase commit)
          - 여러 노드에 걸친 원자적 트랜잭션을 보장하는 DB 프로토콜
          - 모든 노드가 성공하던가 실패하던가 하나로 트랜잭션이 마무리되도록 보증
          - 비중단 실행이 가능한 프로토콜이 아니라 한 노드에 장애가 발생하면 해당 장애가 복구될 때까지 진행이 중단됨.
        - 사가(saga)
          - 각 노드에 국지적으로 발생하는 트랜잭션을 하나로 엮은 것
          - 각 트랜잭션은 완료되면 다음 트랜잭션을 시작하는 트리거로 쓰일 메시지를 보냄
          - 한 트랜잭션이라도 실패 시 이전 트랜잭션 결과를 전부 되돌리는 트랜잭션들을 순차적으로 실행함.
        - 2PC는 여러 노드에 걸친 하나의 트랜잭션으로 ACID를 만족시키는 개념이고, 사가는 각 단계가 하나의 트랜잭션이라 결과적 일관성에 의존하는 것임
- MSA에서 데이터 불일치를 해결하기 위해 사용되는 복잡한 메커니즘은 시스템 전체 설계의 복잡성을 크게 증가시킴
- 증가한 복잡성이 그만한 가치가 있는지 결정하는 것은 설계자의 몫임


## 4단계 - 마무리

---

# 8장 - 분산 이메일 서비스

## 1단계 - 문제 이해 및 설계 범위 확정
- 설계 범위 확정
  - Q) 사용자는 얼마나 되는가?
    - A) 10억 명
  - Q) 핵심 기능
    - 인증
    - 이메일 발송/수신
    - 모든 이메일 가져오기 
    - 읽기 여부에 따른 이메일 필터링
    - 제목, 발신인, 메일 내용에 따른 검색 기능
    - 스팸 및 바이러스 방지 기능
    - A) 좋음. 다만 인증은 건너 뜀
  - Q) 사용자는 메일 서버에 어떻게 연결하는가?
    - A) 전통적으로는 SMTP, POP, IMAP 등의 프로토콜과 서비스 제공자 전용 프로토콜을 사용해 접속함. 이번에는 HTTP를 사용한다고 가정
  - Q) 첨부 파일도 지원하는가?
    - A) ㅇㅇ

### 비기능 요구사항
- 안정성
  - 이메일 데이터는 소실되어서는 안된다.
- 가용성
  - 이메일과 사용자 데이터를 여러 노드에 자동으로 복제하여 가용성을 보장해야함.
- 확장성
  - 사용자 수가 늘어나도 감당할 수 있어야 함.
  - 사용자나 이메일이 많아져도 시스템 성능은 저하되지 않아야 함.
- 유연성과 확장성
  - 쉽게 기능을 추가하고 성능을 개선할 수 있어야 함.
  - POP나 IMAP 같은 기존 이메일 프로토콜 기능이 매우 제한적임.
  - 유연성과 확장성을 갖추려면 맞춤형 프로토콜이 필요할 수 있음.

### 개략적인 규모 추정
- 10억 명의 사용자
- 한 사람이 보내는 하루 평균 이메일은 10건이라고 가정.
- QPS = 100_000
  - 10^9 * 10 / 10^5
- 한 사람이 하루에 수신하는 이메일 수는 평균 40건이라고 가정.
  - 이메일 하나의 메타 데이터는 평균 50KB라고 가정.
  - 메타데이터는 주어진 이메일에 대한 모든 정보이며, 첨부 파일은 포함하지 않음
- 메타데이터는 DB에 저장한다고 가정.
  - 1년간 메타데이터를 유지하기 위한 스토리지 요구사항은 730PB
    - 10억 사용자 * 하루 40건의 이메일 * 365일 * 50KB
- 첨부 파일을 포함하는 비율은 20%라고 가정하고, 첨부 파일의 평균 크기는 500KB라고 가정
- 1년 간 첨부 파일 보관에 필요한 저장 용량은 1460PB
  - 10억 사용자 * 하루 40개 이메일 * 365일 * 20% * 500KB

## 2단계 - 개략적 설계안 제시 및 동의 구하기
### 이메일 101 - 이메일 프로토콜
- SMTP(Simple Mail Transfer Protocol)
  - 이메일을 한 서버에서 다른 서버로 보내는 표준 프로토콜
- POP
  - 이메일 가져오는 목적으로 가장 널리 사용되는 프로토콜
  - 이메일 클라이언트 가 원격 메일 서버에서 이메일을 수신하고 다운로드하기 위해 사용하는 표준 프로토콜
  - 단말로 다운로드된 이메일은 서버에서 삭제되므로 한 대의 단말에서만 이메일을 읽을 수 있다.
  - 이메일을 확인하려면 전부 내려 받아야 함.
  - 용량이 큰 첨부 파일이 붙은 이메일을 읽는 데 오랜 시간이 걸림
- IMAP
  - 이메일 클라이언트가 원격 메일 서버에서 이메일을 수신하는 데 사용되는 또 다른 표준 프로토콜
  - POP과 달리 클릭하지 않으면 메시지는 다운로드 되지 않으며, 메일 서버에서 지워지지도 않음
  - 여러 단말에서 이메일을 읽을 수 있음
  - 개인 이메일 계정에서 가장 널리 사용되는 프로토콜임
  - 이메일을 실제로 열기 전에는 헤더만 다운로드함
    - 인터넷 속도가 느려도 잘 동작한다
- HTTPS
  - HTTPS는 메일 전송 프로토콜이 아님.
  - 웹 기반 이메일 시스템의 메일함 접속에 이용될 수 있음
  - MS의 아웃룩은 액티브 싱크(ActiveSync)라는 HTTPS 기반 자체 프로토콜을 통해 모바일 단말과 통신을 처리

### 도메인 이름 서비스
- DNS 서버는 수신자 도메인의 메일 교환기 레코트(MX, Mail Exchange) 검색에 사용됨

### 첨부 파일
- 이메일 첨부 파일은 이메일 메시지와 함께 전송되며 일반적으로 Base64 인코딩을 사용
- 일반적으로 파일 크기 제안이 있음

### 전통적 메일 서버
- 서버 한 대로 운용되는 사용자가 많지 않는 상황에 잘 동작하는 시스템
- 프로세스
  - 로그인 후 이메일을 작성해 '발송' 버튼을 누름.
    - 이메일은 메일 서버로 전송됨.
    - 클라이언트와 메일 서버 사이의 통신 프로토콜은 SMTP임
  - 메일 서버는 DNS 질의를 통해 수신자 SMTP 서버 주소를 찾음
    - 주소를 찾은 후에 해당 메일 서버로 메일을 보냄
    - 메일 서버 간 통신도 SMTP임
  - 수신 받은 메일 서버는 이메일을 저장하고 수신자가 읽어갈 수 있도록 함
  - 수신자 메일 클라이언트는 IMAP/POP 서버를 통해 새 이메일을 가져옴
- 저장소
  - 각각의 메일은 고유한 이름을 가진 별도 파일로 보관됨
  - 각 사용자의 설정데이터와 메일함은 사용자 디렉토리에 보관됨
  - 사용자가 많지 않을 때는 잘 동작하지만, 사용자가 많아지면 성능이 저하됨
  - 메일 양이 많아지고 파일 구조가 복잡해지면 디스크 I/O가 병목이 되곤 했음

### 분산 메일 서버 - 이메일 API
- 이메일 API의 의미는 메일 클라이언트와 이메일 생명주기 단계마다 달라질 수 있음
  - 모바일 단말 클라이언트를 위한 SMTP/POP/IMAP API
  - 송신 측 메일 서버와 수신 측 메일 서버 간의 SMTP 통신
  - 대화형 웹 기반 이메일 애플리케이션을 위한 HTTP 기반 RESTful API
- POST /v1/messages 엔드포인트
  - To, Tc, Bcc 헤더에 명시된 수신자에게 메시지를 전송
- GET /v1/folders 엔드포인트
  - 주어진 이메일 계정에 존재하는 모든 폴더를 반환
  - 응답 형식
    - [{id: string, name: string, user_id: string}]
    - id : 고유한 폴더 식별자
    - name : 폴더 이름
    - user_id : 폴더 소유자 ID
- GET /v1/folders/{:folder_id}/messages 엔드포인트
  - 주어진 폴더 아래 모든 메시지를 반환
  - 응답 형식
    - 메시지 객체 목록
- GET /v1/messages/{:message_id} 엔드포인트
  - 주어진 메시지 ID에 대한 메시지 객체를 반환
  - 이메일 애플리케이션의 핵심 구성 요소로, 발신자, 수신자, 메시지 제목, 본문, 첨부 파일 등의 정보로 구성됨
  - 응답 형식
    - {id: string, user_id: string, subject: string, from: {name: string, email: string}, to: [name: string, email: string,], body: string, is_read: Boolean}
    - id : 고유한 메시지 식별자
    - user_id : 계정주의 ID
    - subject : 제목
    - from : 발신인 <이름, 이메일> 쌍 
    - to : 수신인 <이름, 이메일> 쌍의 목록
    - body : 본문 내용 
    - is_read : 읽음 여부

### 분산 메일 서버 - 아키텍처
- 여러 서버 사이에서 데이터를 동기화하는 것은 어려움
- 수신자 메일 서버에서 이메일이 스팸으로 잘못 분류되지 않도록 하려면 까다로운 문제들을 풀어야 함
- 웹 메일
  - 사용자는 웹 브라우저를 통해 메일을 받고 보냄
- 웹 서버
  - 사용자가 이용하는 요청/응답 서비스
  - 로그인, 가입, 사용자 프로파일 등에 대한 관리 기능을 담당
  - 여기서는 이메일 발송, 폴더 목록 확인, 폴더 내 모든 메시지 확인 등의 모든 이메일 API 요청은 전부 웹 서버를 통함
- 실시간 서버
  - 새로운 이메일 내역을 클라이언트에 실시간으로 전달하는 역할을 담당
  - 실시간 서버는 지속성 연결을 맺고 유지해야 하므로 상태 유지 서버임
  - 롱폴링이나 웹소켓 등을 이용함
  - 웹소켓이 더 우아하지만 브라우저 호환성 문제가 있을 수 있음
    - 웹소켓을 기본적으로 이용하고, 여의치 않으면 롱 폴링을 백업으로 이용할 수 있음
  - 아파치 제임스 같은 경우 웹소켓 위에 JMAP(JSON Meta Application Protocol)을 구현함
- 메타데이터 DB
  - 이메일 제목, 본문, 발신인, 수신인 목록 등의 메타 데이터를 저장하는 DB
- 첨부 파일 저장소
  - 아마존 S3같은 객체 저장소를 사용함
  - 카산드라 같은 NoSQL을 사용하지 않는 이유
    - BLOB(Binary Large Object)를 지원하고, 최대 2GB지만 실질적으로는 1MB 이상의 파일을 지원하지 못 함
    - 카산드라에 첨부 파일 저장 시 레코드 캐시를 사용하기 어려움. 첨부파일이 너무 많은 메모리를 잡아먹기 때문임
- 분산 캐시
  - 최근 수신된 메일이 자주 읽힐 가능성이 높으므로 클라이언트로 하여금 메모리에 캐시해두면 메일 표시 속도가 빨라짐
- 검색 저장소
  - 분산 문서 저장소
  - 고속 텍스트 검색을 지원하는 역 인덱스를 자료 구조로 사용함

### 분산 메일 서버 - 이메일 전송 절차
- 전송 절차
  - 사용자가 웸메일 환경에서 메일을 작성 후 전송 버튼을 누름.
    - 요청은 로드밸런서로 전송됨
  - 로드밸런서는 처리율 제한 한도를 넘지 않는 선에서 요청을 웹 서버로 전달
  - 웹 서버는 다음 역할을 담당
    - 기본적인 이메일 검증
      - 메일 크기 한도처럼 사전에 미리 정의된 규칙을 사용해 메일을 검사
    - 수신자 이메일 주소 도메인이 송신자 이메일 주소 도메인과 같은지 검사
      - 같을 경우 웹 서버는 이메일 내용의 스팸 여부와 바이러스 감염 여부를 검사
      - 검사를 통과하면 송신인의 '보낸 편지함'과 수신인의 '받은 편지함'에 저장됨
      - 수신인측 클라이언트는 RESTful API를 통해 메일을 가져옴
      - 이후 단계는 수행할 필요가 없음
  - 메시지 큐
    - 기본적인 검증을 통과한 메일은 외부 전송 큐로 전달됨
    - 큐에 넣기에 첨부 파일이 큰 경우 첨부 파일은 객체 저장소에 저장하고 큐에는 해당 저장 위치에 대한 참조 정보만 보관
    - 기본적인 검증에 실패한 메일은 에러 큐에 보관
  - 외부 전송 담당 SMTP 작업 프로세스는 외부 전송 큐에서 메시지를 꺼내 이메일의 스팸 및 바이러스 감염 여부를 확인
  - 검증 절차를 통과한 이메일은 저장소 계층 내의 '보낸 편지함'에 저장됨
  - 외부 전송 담당 SMTP 작업 프로세스가 수신자의 메일 서버로 메일을 전송
- 외부 전송 큐에 보관되는 모든 메시지에는 이메일 생성에 필요한 모든 메타데이터가 포함됨
- 분산 메시지 큐는 비동기적 메일 처리를 가능하게 하는 핵심 컴포넌트임
- 메일이 처리되지 않고 큐에 오래 남아있을 경우 원인일 수 있는 문제
  - 수신자 측 메일 서버에 장애 발생
    - 나중에 메일을 다시 전송해야함.
    - 지수적 백오프(Exponential Backoff)가 좋은 전략일 수 있음
  - 이메일을 보낼 소비자 수가 불충분
    - 더 많은 소비자를 추가해 처리 시간을 단축할 수 있음

### 분산 메일 서버 - 이메일 수신 절차
- 수신 절차
  - 이메일이 SMTP 로드밸런서에 도착
  - 로드밸런서는 여러 SMTP 서버로 분산함
    - SMTP 연결에는 이메일 수락 정책을 구성해 적용할 수 있음
      - 유효하지 않은 이메일을 반송하게하는 등
  - 이메일의첨부 파일이 큐에 들어가기 너무 큰 경우 첨부 파일 저장소(S3 등)에 보관
  - 이메일을 수신 이메일 큐에 넣음.
    - 이 큐는 메일 처리 작업 프로세스와 SMTP 서버 간의 결합도를 낮춰줌
    - 갑자기 메일의 양이 폭증하는 경우 버퍼의 역할도 수행함
  - 메일 처리 작업 프로세스는 스팸 메일을 걸러내고 바이러스를 차단하는 등의 다양한 역할을 함.
    - 아래 절차들은 검증 작업 후 이메일을 대상으로 함
  - 이메일을 메일 저장소, 캐시, 객체 저장소 등에 보관
  - 수신자가 온라인 상태인 경우 이메일을 실시간 서버로 전달
  - 실시간 서버는 수신자 클라이언트가 새 이메일을 실시간으로 받을 수 있도록 하는 웹소켓 서버임
  - 오프라인 상태 사용자의 이메일은 저장소 계층에 보관함
    - 해당 사용자가 온라인 상태가 되면 웹메일 클라이언트는 웹 서버에 RESTful API를 통해 연결함
  - 웹 서버는 새로운 이메일을 저장소 계층에서 가져와 클라이언트에 반환

## 3단계 - 상세 설계
### 메타데이터 DB
- 메타데이터의 특성을 공부하고 올바른 DB와 데이터 모델을 고르는 문제, 이메일 타래(thread) 지원 방안에 대해 알아보자 

### 메타데이터 DB - 이메일 메타데이터의 특성
  - 이메일의 헤더는 일반적으로 작고, 빈번하게 사용됨
  - 본문의 크기는 작은 것에서 큰 것까지 다양하지만 사용 빈도는 낮음. 일반적으로 사용자는 이메일을 한 번만 읽음
  - 이메일 가져오기, 읽은 메일로 표시, 검색 등의 작업은 사용자 별로 격리 수행되어야 함.
    - 어떤 사용자의 이메일은 해당 사용자만 읽을 수 있어야 하고, 그 메일에 대한 작업도 그 사용자만 수행할 수 있어야 함
  - 데이터의 신선도는 데이터 사용 패턴에 영향을 미침
    - 사용자는 보통 최근 메일만 읽음.
    - 만들어진 지 16일 이하 데이터에서 발생하는 읽기 비율이 전체 질의의 82%에 달함
  - 데이터의 높은 안정성을 보장해야 함. 손실은 절대 나면 안됨

### 메타데이터 DB - 올바른 데이터베이스 선정
- 규모가 커지면 초당 입/출력 연산 빈도(IOPS, Input/Output Operations Per Second)를 낮추기 위해 맞춤 제작한 DB를 사용함
- RDB
  - 메일을 효율적으로 검색할 수 있음
  - 이메일 헤더와 본문에 대한 인덱스를 만들어 두면 간단한 검색 질의는 빠르게 처리할 수 있음
  - 데이터 크기가 작을 때 적합함.
  - HTML 등이 포함되면 100KB는 쉽게 넘어감.
  - 비정형 BLOB 자료형 데이터에 대한 검색 질의 성능은 좋지 않음
    - BLOB 자료형이 고정된 크기 페이지를 연결해 큰 데이터를 저장하고 있어서 해당 컬럼의 데이터에 접근할 때마다 많은 디스크 I/O가 발생하기 때문임
  - 따라서 RDB는 적합하지 않음.
- 분산 객체 저장소
  - 이메일의 원시 데이터를 그대로 아마존 S3 같은 객체 저장소에 보관하는 것
  - 백업 데이터를 보관하기엔 좋지만 이메일의 읽음 표시, 키워드 검색, 이메일 타래 등의 기능을 구현하기에 좋지 않음
- NoSQL
  - 구글은 빅테이블(Bigtable)을 저장소로 사용함.
    - 하지만 빅테이블은 오픈소스로 공개되어 있지 않음
  - 카산드라가 대안이 될 수 있으나 현재 카산드라를 사용하는 대형 이메일 서비스 제공 업체는 없음
- 대형 이메일 서비스는 대체로 독자적인 DB를 만들어서 사용함
  - 어떤 단일 칼럼의 크기는 한 자릿수 MB 정도일 수 있음
  - 강력한 데이터 일관성이 보장되어야 함
  - 디스크 I/O가 최소화되록 설계되어야 함
  - 가용성이 아주 높아야 하고 일부 장애를 감내할 수 있어야 함
  - 증분 백업(incremental backup)이 쉬워야 함

### 메타데이터 DB - 데이터 모델
- user_id를 파티션 키로 사용해 특정 사용자의 데이터를 항상 같은 샤드에 보관하는 방법
  - 메시지를 여러 사용자와 공유할 수 없다는 문제가 있음
    - 현재 상황처럼 요구사항에 관계 없을 땐 가능함
- 기본 키
  - 파티션 키와 클러스터 키 두 가지 부분으로 구성
  - 파티션 키
    - 데이터를 여러 노드에 분산하는 구실
    - 일반적인 규칙은 데이터가 모든 노드에 균등하게 분산되도록 하는 파티션 키를 골라야 함
  - 클러스터 키
    - 같은 파티션에 속한 데이터를 정렬하는 구실
- 지원할 수 있어야 하는 질의
  - 주어진 사용자의 모든 폴더를 구함
  - 특정 폴더 내의 모든 이메일을 표시
  - 메일을 새로 만들거나, 삭제하거나, 가져옴
  - 이미 읽은 메일 전부, 또는 읽지 않은 모든 메일을 가져옴
  - 보너스 점수를 받을 수 있는 질의
    - 이메일 타래를 전부 가져온다
- 특정 사용자의 모든 폴더 질의
  - 파티션 키가 user_id이므로 어떤 사용자의 모든 폴더는 같은 파티션 내부에 존재함
- 특정 포더에 속한 모든 메일 표시
  - 자신의 메일 폴더를 열면 가장 최근 이메일부터 오래된 순으로 정렬되어 표시됨
  - 같은 폴더에 속한 모든 메일이 같은 파티션에 속하게 하려면 <user_id, folder_id>를 파티션 키로 사용해야 함
  - email_id를 TIMEUUID로 사용하면 시간순 정렬에 사용하기 좋은 클러스터 키가 됨
- 이메일 생성/삭제/수신
  - 이메일 상세 정보를 가져오는 방법만 설명
  - email_id와 filename 필드를 같이 사용하면 모든 첨부 파일 질의가 가능함
- 읽은 또는 읽지 않은 모든 메일
  - RDB로 도메인 모델을 구현하는 경우
    - SELECT * FROM email_by_folder WHERE user_id = <user_id> AND folder_id = <folder_id> AND is_read = true ORDER BY email_id
  - 하지만 이번 설계에서는 NoSQL을 사용함
    - NoSQL DB는 보통 파티션 키와 클러스터 키에 대한 질의만 허용함
      - 주어진 폴더에 속한 모든 메시지를 가져온 다음 애플리케이션 단에서 필터링
        - 대규모 서비스에는 적합하지 않음
      - NoSQL DB 테이블을 비정규화해 해결하는 것이 보통
      - email_by_folder 테이블을 두 테이블로 분할
        - read_emails
        - unread_emails
        - 읽음 표시를 위해서는 unread_emails 테이블에서 삭제하고 read_emails 테이블에 추가함
- 보너스 : 이메일 타래 가져오기
  - 많은 이메일 클라이언트가 지원하는 기능
  - 모든 답장을 최초 메시지에 타래로 엮어 보여주는 기능
  - 전통적으로 이메일 타래는 JWZ 같은 알고리즘을 통해 구현함
- 일관성 문제
  - 높은 가용성을 위해 다중화에 의존하는 분산 DB는 일관성과 가용성 사이의 타협을 할 수 밖에 없음
  - 이메일 시스템은 데이터의 정확성이 중요하므로 모든 메일함은 반드시 하나의 주(primary) 사본을 통해 서비스된다고 가정
  - 장애 발생 시 클라이언트는 다른 사본을 통해 주 사본이 복원될 때까지 동기화/갱신 작업을 완료할 수 없음

### 이메일 전송 가능성
- 메일 서버를 구성하고 메일을 보내는 것은 쉽지만, 특정 사용자의 메일함에 실제로 메일이 전달되게 하는 것은 어렵다
- 스태티스타 사의 연구에 따르면 모든 메일 가운데 50%가 스팸으로 분류됨
- 이메일 전송 가능성을 높이기 위해 고려해야할 요소
  - 전용 IP
    - 대부분의 이메일 서비스는 아무 이력이 없는 새로운 IP 주소에서 온 이메일을 스팸으로 분류함
  - 범주화
    - 범주가 다른 이메일은 다른 IP를 통해 보내라
    - 마케팅 목적의 메일과 중요한 메일의 서버를 분리하라
  - 발신인 평판
    - 새로운 이메일 서버의 IP 주소는 사용 빈도를 서서히 올리는 것이 좋다.
  - 스팸 발송자의 신속한 차단
    - 스팸은 발송하는 사용자는 빠르게 차단해야함
  - 피드백 처리
    - 불만 신고 접수 비율과 스팸을 신속히 차단하기 위해서는 ISP 측에서 피드백을 찾아 빠르게 처리하는 경로를 만드는 것이 중요함
    - 경성 반송
      - 수신인의 메일 주소가 올바르지 않아 ISP가 전달을 거부한 경우
    - 연성 반송
      - ISP측의 메일 처리 자원 부족 등의 이유로 일시적으로 메일 전달이 안되는 경우
    - 불만 신고
      - 수신인이 '스팸으로 신고' 버튼을 누른 경우

### 검색
- 다양한 검색 기능을 제공하기 위해서는 메일이 전송, 수신, 삭제될 때마다 색인 작업을 수행해야 함
- 그에 반해 검색은 사용자가 '검색'버튼을 누를 때만 실행됨
- 따라서 이메일 시스템의 검색 기능에서는 쓰기 연산이 읽기 연산보다 훨씬 많이 발생함

| | 범위 | 정렬 | 정확도 |
|---|---|---|---|
| 구글 검색 | 인터넷 전체 | 관련성에 따라 | 색인에 시간이 걸리므로 새로운 항목은 검색 결과에 즉시 나타나지 않을 수 있음 |
| 이메일 검색 | 사용자의 메일함 | 시각, 첨부 파일, 날짜 범위 내, 읽음 여부 등의 속성을 기준으로 정렬 | 색인 작업은 거의 실시간으로 이루어져야하고 검색 결과는 정확해야 함 |

- 엘라스티서치 사용
  - 같은 사용자의 이메일은 user_id를 파티션 키로 사용해 묶음
  - 사용자는 검색 버튼을 누른 후 결과가 수신될 때까지 기다려야 함.
    - 검색 결과는 메일함에 있는 모든 이메일을 검색해야 하므로 시간이 걸림.
    - 동기 방식으로 처리되어야 함
  - 이메일 전송/수신/삭제 같은 이벤트는 비동기 처리가 가능
- 맞춤형 검색 솔루션
  - 이메일 서비스는 보통 자신의 제품에 고유한 요구사항에 맞는 검색 엔진을 자체적으로 개발해 사용함
  - 일단 검색 솔루션 구현 시 주요 과제인 디스크 I/O 병목만 다룸
  - 메일 저장소에 추가되는 메타데이터와 첨부 파일의 양은 페타바이트(PB) 수준임
    - 따라서 메일 색인 서버의 주요 병목은 보통 디스크 I/O임
    - 색인 구축 프로세스는 다량의 쓰기 연산이 발생하므로 LSM(Log-Structured Merge) 트리 구조를 사용함
    - LSM 트리는 빅테이블이나 카산드라, RocksDB 등에 사용되는 핵심 자료 구조임
  - 새로운 메일은 메모리 캐시로 구현되는 최하위 계층에 추가됨
  - 각 층에서 임계치를 넘으면 다음 계층에서 병합됨
  - LSM을 사용하는 또 다른 이유는 자주 바뀌는 데이터와 그렇지 않은 데이터를 분리하기 위함임

|  | ElasticSearch                                                    | 맞춤형 검색 엔진 |
| --- |------------------------------------------------------------------| --- |
| 규모 확장성 | 어느 정도 확장 가능                                                      | 이메일 사용 패턴에 따라 시스템 최적화 가능 |
| 시스템 복잡도 | 두 가지 상이한 시스템을 동시에 유지해야 함                                         | 하나의 시스템 |
| 데이터 일관성 | 한 데이터의 두 사본이 존재 (메타데이터 저장소 / ElasticSearch) → 데이터 일관성을 유지하기 까다로움 | 메타데이터 저장소에 하나의 사본만 유지 |
| 데이터 손실 가능성 | X → 색인이 손상되면 주 저장소의 데이터로 복구                                      | X |
| 개발 비용 | 통합하기 쉬운 편. 대규모 이메일 검색이 필요한 경우에는 전담하는 팀의 리소스 필요                   | 굉장히 많은 엔지니어링 노력이 필요함 |

- 소규모 이메일 시스템의 경우 엘라스티 서치가 좋은 선택지임.
- 통합하기 쉽고 엔지니어링에 많은 노력이 필요하지도 않음

### 규모 확장성 및 가용성
- 각 사용자의 데이터 접근 패턴은 다른 사용자와 무관함.
  - 시스템의 대부분의 컴포넌트는 수평적 규모 확장이 가능함
- 장애 발생 시 사용자는 다른 데이터센터에 보관된 메시지를 이용함

## 4단계 - 마무리
- 추가로 논의해볼 만한 주제
  - 결함 내성
    - 노드 장애, 네트워크 문제, 이벤트 전달 지연 등의 문제에 어떻게 대처할지
  - 규정 준수
    - 전 세계 다양한 시스템과 연동해야하고 각 나라 별 법규가 존재함
  - 보안
  - 최적화
    - 때로는 같은 메일이 여러 수신자에게 전송됨.
    - 첨부 파일이 그룹 이메일 객체 저장소(S3)에 여러 번 저장되는 경우가 있음.
    - 저장하기 전 저장소에 이미 동일한 파일이 있는지 확인해서 저장 연산 비용을 최적화해야함 