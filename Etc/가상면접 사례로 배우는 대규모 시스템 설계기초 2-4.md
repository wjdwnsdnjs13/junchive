# 7장 - 호텔 예약 시스템

## 1단계 - 문제 이해 및 설계 범위 확정
- 설계 범위 확정
  - Q) 시스템 규모?
    - A) 5000개 호텔에서 100만 개의 객실을 갖춘 호텔 체인을 위한 웹 사이트 구현
  - Q) 대금은 예약 시인지, 호텔 도착 시인지?
    - A) 시간 제한이 있어 예약 시 전부 지불로 가정
  - Q) 웹사이트에서만 예약이 되는가, 전화 같은 것도 되는가?
    - A) 웹 사이트나 앱에서만 가능.
  - Q) 예약 취소 기능은?
    - A) 물론임
  - Q) 추가 고려 사항은?
    - A) 10% 초과 예약이 가능해야 함. 실제 객실보다 많이 판매 가능
  - Q) 시간이 제한되어 있어 검색은 제외하고자 함.
    - 호텔 정보 페이지
    - 객실 정보 페이지
    - 객실 예약 지원
    - 호텔이나 객실 정보 추가/삭제/갱신하는 관리자 페이지
    - 초과 예약 지원
    - A) 굳
    - A) 객실 가격은 유동적임. 객실 여유에 따라 유동적으로 변경되며 매일 달라짐

### 비기능 요구 사항
- 적절한 지연 시간
  - 예약 시 응답 시간이 빠르면 이상적인데, 몇 초 정도 지연은 괜찮음

### 개략적 규모 추정
- 5000개 호텔, 100만 개의 객실
- 객실의 70%가 사용 중이고, 평균 투숙 기간은 3일이라고 가정
- 일일 예약 건수 : 233_333건
  - 100만 * 0.7 / 3
- 초당 예약 건수 약 3건(TPS)
  - 240_000 / 하루
- 웹 사이트 사용 흐름
  - 호텔/객실 상세 페이지
    - 호텔/객실 정보를 확인 -> 조회
  - 예약 상세 정보 페이지
    - 사용자가 날짜, 투숙 인원, 결제 방법 등의 상세 정보 확인 -> 조회
  - 객실 예약 페이지
    - 사용자가 '예약'버튼을 눌러 객실을 예약 -> 트랜잭션 발생
- 대략 10%만 다음 단계로 진입하고 그 외에는 흐름을 이탈한다고 가정
  - 객실 상세 페이지 QPS = 300
  - 예약 상세 정보 페이지 QPS = 30
  - 객실 예약 페이지 QPS = 3

## 2단계 - 개략적 설계안 제시 및 동의 구하기
### API 설계 - 호텔 관련 API
| API                        | 설명              |
|----------------------------|-----------------|
| GET v1/hotel/{hotel_id}    | 호텔 정보 조회        |
| POST v1/hotels             | 신규 호텔 추가, 직원 전용 |
| PUT v1/hotel/{hotel_id}    | 호텔 정보 갱신, 직원 전용 |
| DELETE v1/hotel/{hotel_id} | 호텔 삭제, 직원 전용    |

### API 설계 - 객실 관련 API
| API                                      | 설명              |
|------------------------------------------|-----------------|
| GET v1/hotels/{hotel_id}/rooms/{room_id} | 객실 정보 조회        |
| POST v1/hotels/{hotel_id}/rooms          | 신규 객실 추가, 직원 전용 |
| PUT v1/hotels/{hotel_id}/rooms/{room_id} | 객실 정보 갱신, 직원 전용 |
| DELETE v1/hotels/{hotel_id}/rooms/{room_id} | 객실 삭제, 직원 전용    |

### API 설계 - 예약 관련 API
| API                                   | 설명            |
|---------------------------------------|---------------|
| GET v1/reservations | 사용자의 예약 이력 조회 |
| GET v1/reservations/{reservation_id} | 예약 정보 조회 |
| POST v1/reservations | 객실 예약 |
| DELETE v1/reservations/{reservation_id} | 예약 취소 |

### 데이터 모델
- 예약 시스템이 지원해야 할 질의
  - 호텔 상세 정보 확인
  - 지정된 날짜 범위에 사용 가능한 객실 유형 확인
  - 예약 정보 기록
  - 예약 내역 또는 과거 예약 이력 정보 조회
- RDB를 선택
  - 읽기 쓰기 빈도가 쓰기 연산에 비해 높은 흐름을 잘 지원함
    - 웹 사이트와 앱을 방문하는 사용자 수가 예약자 수에 비해 압도적으로 많음
    - NoSQL은 쓰기 연산에 최적화 되어 있음
  - ACID(원자성, 일관성, 고립성, 지속성)을 보장함
    - 예약에서 ACID는 매우 중요함
    - 이중 청구, 잔액 마이너스, 이중 예약 등 방지가 필요함
  - 비즈니스 데이터 구조를 쉽게 모델링 가능
    - 엔티티 간의 관계를 안정적으로 지원

### RDB 엔티티 설계 시 주의점
- room_id가 에어비엔비 같은 회사에는 적합하지만, 호텔에는 그렇지 않을 수 있음.
- 호텔은 특정 룸을 예약하기 보다 '특정 객실 유형'을 예약하기 때문임

### 개략적 설계안
- 사용자
  - 객실을 예약하는 당사자
- 관리자(호텔 직원)
  - 고객 환불, 예약 취소, 객실 정보 갱신 등의 관리 작업을 수행
- CDN
  - JS 코드 번들, 이미지, 동영상, HTML 등 모든 정적 콘텐츠를 캐시해 웹 사이트 로드 성능을 개선
- 공개 API 게이트웨이
  - 처리율 제한, 인증 등의 기능을 지원하는 완전 관리형 서비스
  - 엔드포인트 기반으로 특정 서비스에 요청을 전달할 수 있게 구성
- 내부 API
  - 승인된 호텔 직원만 사용 가능한 API
  - VPN 등을 이용해 외부 공격으로부터 보호함
- 호텔 서비스
  - 호텔과 객실에 대한 정보를 제공
  - 대부분 정적이라 쉽게 캐시 가능
- 요금 서비스
  - 어떤 때에 어떤 요금을 받아야 하는지 데이터를 제공하는 서비스
  - 객실 요금이 해당 날짜에 호텔에 얼마나 손님이 몰리냐에 따라 달라짐
- 예약 서비스
  - 예약 요청을 받고 객실을 예약하는 과정을 처리.
  - 객실이 예약되거나 취소될 때 잔여 객실 정보를 갱신하는 역하도 담당
- 결제 서비스
  - 고객의 결제를 맡아 처리하고, 절차가 마무리되면 예약 상태를 결제 완료로 갱신
  - 실패한 경우 승인 실패로 업데이트
- 호텔 관리 서비스
  - 승인된 호텔 지원만 사용 가능.
  - 임박한 예약 기록 확인, 고객 객실 예약, 예약 취소 등의 기능을 제공

## 3단계 - 상세 설계
### 개선된 데이터 모델
- API 인자 변경
  - 예약 API에서 호출 인자를 roomID -> roomTypeID로 변경
- 스키마 변경
  - room 스키마에서 room_type_iD를 추가
  - 예약 서비스쪽 스키마에서도 room_id -> room_type_id로 변경
  - room_type_inventory 테이블
    - 호텔의 모든 객실 유형을 담는 테이블
    - 예약 시 아주 중요함.
    - hotel_id : 호텔 식별자
    - room_type_id : 객실 유형 식별자
    - date : 일자
    - total_inventory : 총 객실 수에서 일시적으로 제외한 객실 수를 뺀 값
      - 유지 보수 등의 사유로 예약 불가능 할 수 있음
    - total_reserverd : 지정된 hotel_id, room_type_id, date에 대한 예약된 객실 수
    - 날짜당 하나의 레코드를 사용 시 날짜 범위 내에서 예약을 쉽게 관리하고 질의 가능함
    - hotel_id, room_type_id, date를 복합 키로 사용함
    - 5000개의 호텔이 있고 각 호텔에 20개의 객실 유형이 있을 경우 레코드의 수 = 7_300만 개
      - 5000 * 20 * 2년 * 365

### 동시성 문제
- 해결해야 할 문제 두 가지
  - 같은 사용자가 예약 버튼을 여러 번 누르는 경우
    - 클라
      - 클라에서 요청 전송 후 '예약'버튼 비활성화
    - 멱등(idempotent) API
      - 예약 API 요청에 멱등 키를 추가
      - 몇 번을 호출해도 같은 결과를 내는 API를 멱등 API라고 함
  - 여러 사용자가 같은 객실을 동시에 예약하는 경우

### 멱등 키
- 예약 주문서를 생성
- 고객이 검토할 수 있게 예약 주문서를 반환
  - 이때 API는 반환 결과에 멱등 키 reservation_id를 포함함
    - 전역적 유일성을 보장하는 ID 생성기가 만들어낸 키여야 함
- 검토가 끝난 예약 전송(reservation_id 포함)
- 사용자가 예약 완료 버튼 클릭 한 번 더 클릭해도 reservation_id가 이미 있으므로 새로운 레코드는 생성되지 않음.

### 잔여 객실이 하나일 때 여러 사용자가 예약하는 경우
- 트랜잭션 격리 수준이 가장 높은 serializable이 아닐 때
- 트랜잭션 A가 commit 되지 않으면 트랜잭션 B는 트랜잭션 A의 변경 사항을 모름.
- 락
  - 비관적 락
  - 낙관적 락
  - 데이터베이스 제약 조건(constraint)

### 비관적 락
- 레코드 갱신하는 순간 즉시 락을 걸어 동시 업데이트를 방지
- 해당 레코드를 갱신하려난 다른 사용자는 먼저 락을 건 사용자가 변경을 끝내고 락 해제까지 기다려야 함.
  - MySQL은 "SELECT ... FOR UPDATE" 쿼리를 사용해 레코드에 락을 검
- 장점
  - 애플리케이션이 변경 중이거나 변경이 끝난 데이터를 갱신하는 일을 막을 수 있음.
  - 구현이 쉽고 모든 갱신 연산을 직렬화해 충돌을 막음.
  - 비관적 락은 데이터에 대한 경합이 심할 때 유용함
- 단점
  - 여러 레코드에 락을 걸면 교착 상태(deadlock)가 발생할 수 있음.
    - Deadlock을 피하는 애플리케이션 코드를 짜는 것은 까다로울 수 있음
  - 확장성이 낮음.
    - 트랜잭션이 오랫동안 락을 해제하지 않으면 다른 트랜잭션은 락이 걸린 자원에 접근이 안됨.
    - 트랜잭션의 수명이 길거나 많은 엔티티에 관련된 경우 DB 성능에 심각한 영향을 줌

### 낙관적 락
- 여러 사용자가 동시에 같은 자원을 갱신하려 시도하는 것을 허용함
- 버전 번호와 타임스탬프 두 가지 방법으로 구현함
  - 서버 시계는 시간이 지남에 따라 부정확해질 수 있어서 일반적으로 버전 번호를 더 선호함
- 구현 방법
  - 테이블에 version 컬럼을 추가함
  - 레코드 수정 전 version을 읽어옴
  - 수정 시 version 번호에 1을 추가해 DB에 다시 기록함
    - 이때 유효성를 통해 다음 버전 번호는 현재 버전보다 1 큰 값이어야 함.
    - 유효성 검사가 실패되면 트랜색션은 중단(abort)되고 2단계부터 다시 시작함.
- 비관적 락보다 일반적으로 빠름.
  - 락을 걸지 않기 때문임.
  - 다만, 동시성 수준이 높으면 성능이 급격하게 나빠짐
    - 많은 클라이언트가 동시에 예약하는 경우
    - 모든 클라이언트에서 같은 잔여 객실 수와 버전 정보를 취득함.
    - 이 중 단 하나의 클라이언트만 갱신에 성공함.
    - 실패한 모든 클라이언트는 retry를 함
    - 하지만, 매번 성공하는 클라이언트는 하나임
- 장점
  - 애플리케이션이 유효하지 않은 데이터를 편집하는 일을 막음
  - DB 자원에 락을 걸 필요가 없음
    - 버전 정보를 통해 데이터 일관성을 유지하는 책임은 애플리케이션에게 있음
  - 낙관적 락은 경쟁이 치열하지 않는 상황에 적합하고 락을 관리하는 비용 없이 트랜잭션 처리가 가능함
- 단점
  - 치열한 경쟁에서는 성능이 별로임
- 예약 QPS가 낮아 경쟁이 심하지 않을 수 있어 좋은 선택지임


### DB 제약 조건
- 낙관적 락과 유사함
- CONSTRAINT `check_room_count` CHECK (`total_inventory` >= `total_reserved`) 를 제약 조건에 추가함.
- 사용자가 유휴 객실 이상의 예약을 하게 되면 트랜잭션이 중단되고 rollback됨
- 장점
  - 구현이 쉬움
  - 경쟁이 심하지 않을 때 잘 동작함
- 단점
  - 낙관적 락과 마찬가지로 경쟁이 심하면 실패하는 연산 수가 엄청나게 늘 수 있음
  - 사용자는 객실이 있다고 판단했지만, 실제론 없다는 응답을 받을 수 있음.
  - DB 제약 조건은 애플리케이션 코드와 달라서 버전을 통제하기 어려움
  - 제약 조건을 허용하지 않는 DB도 있으므로, DB 교체 시 문제가 생길 수 잇음
- 예약 QPS가 낮아 경쟁이 심하지 않을 수 있어 좋은 선택지임

### 시스템 규모 확장
- 만약 호텔 웹 사이트만 연동되는 것이 아니라 부킹 닷컴같은 유명 예약 웹 사이트와 연동되어야 하면 어떡하는가?
- 서버는 무상태 서버라 추가하기 쉬워서 성능 문제 해결이 쉬움.
- DB는 DB 서버를 늘리는 것만으로는 성능 문제를 해결할 수 없음

### 시스템 규모 확장 - DB 샤딩
- DB를 여러 대 두고, 각 DB에 데이터의 일부를 저장하는 방법

### 캐시
- 호텔 잔여 객실 데이터는 오직 현재와 미래의 데이터만 중요함
- 데이터 보관 시 낡은 데이터는 자동 소멸되도록 TTL(Time To Live)를 설정할 수 있으면 좋음
- 이력 데이터는 다른 DB에 질의하면 됨
- Redis는 이런 상황에 적합함.
  - TTL과 LRU 캐시 교체 정책으로 메모리를 최적으로 활용 가능
- Redis를 사용하더라도 예약 시 잔여 객실을 DB에서 한 번 더 확인할 필요는 있다.
  - 최종 데이터는 결국 DB에 들어있기 때문임

### 컴포넌트 확인
- 예약 서비스
  - 잔여 객실 관리 API 제공
  - 지정된 호텔과 객실 유형, 주어진 날짜 범위에 이용 가능한 객실의 수 질의
  - 객실 예약 후 total_reserved의 값을 1 증가
  - 고객이 예약을 취소하면 잔여 객실 수를 갱신
- 잔여 객실 캐시
  - 모든 잔여 객실 관리에 필요한 질의는 Redis로 구현되는 잔여 객실 캐시로 옮겨옴
  - 잔여 객실 정보를 캐시에 미리 저장해 두어야 함
  - 키
    - hotelID_roomTypeID_{날짜}
  - 값
    - 주어진 호텔 ID, 객실 유형 ID, 날짜에 맞는 잔여 객실 수
  - 호텔 예약 시스템의 경우 잔여 객실 확인 작업으로 인해 읽기 연산 빈도가 훨씬 많고, 대부분의 읽기 연산은 캐시가 처리함.
- 잔여 객실 DB
  - 잔여 객실 수에 대한 가장 믿을 만한 정보가 보관

### 캐시가 주는 새로운 과제
- 캐시 계층 추가 시 시스템의 확장성과 처리량은 대폭 증가하지만, DB-캐시 사이 일관성 유지에 대한 새로운 문제가 생김
- 사용자가 객실 예약 시 아무 문제가 없는 경우에 새로운 두가지 작업이 이루어짐
  - 잔여 객실 수를 질의해 중분한지 확인(캐시에서 실행)
  - 잔여 객실 데이터를 갱신
    - DB가 먼저 갱신 된 후 캐시에는 비동기적으로 변경 내역 반영
    - 비동기 갱신 작업은 애플리케이션 측에서 수행할 수도 있는데, 그럴 경우 DB에 데이터 저장 후 캐시 데이터를 수정함
    - 변경 데이터 감지(CDD, Change Data Detection) 기술을 사용해 DB에 변경이 생기면 캐시를 갱신하는 방법도 있음
      - 보편적으로 많이 사용되는 솔루션으로 드베지움(Debezium)이라는 것이 있음.
      - DB에서 발생한 변경 내역을 읽는 소스 커넥터로 해서 DB 변화를 감지해 레디스 같은 캐시 시스템에 반영하도록 하는 방안
- 잔여 객실 데이터에 대한 변화를 DB에 먼저 반영해서 캐시에 최신 데이터가 없을 수 있음
  - 하지만, 이런 불일치는 DB가 최종적으로 잔여 객실을 확인하도록하면 문제가 되지 않는다고 볼 수 있음
- 장점
  - 읽기 질의를 캐시가 처리해 DB의 부하가 크게 줄어듦
  - 읽기 질의를 메모리에서 실행하므로 높은 성능을 보장 가능
- 단점
  - DB와 캐시 사이의 데이터 일관성을 유지하는 것은 어려운 문제임
    - 데이터 불일치가 사용자 경험에 어떤 영향을 끼치게 될지 신중히 따져야함

### 서비스 간 데이터 일관성
- 전통적인 모노리스 아키텍처는 데이터 일관성을 위해 RDB를 공유하는 것이 보통임
- MSA 기반의 경우 예약 서비스가 예약 및 잔여 객실 API를 모두 담당하도록 하고, 예약 테이블과 잔여 객실 테이블을 동일한 RDB에 저장하는 하이브리드 접근법을 택함
  - 이를 통해 RDB의 ACID 속성을 이용해 예약 과정에서 발생하는 많은 동시성 문제를 효과적으로 처리함
  - MSA 순수 주의자일 경우 하이브리드 접근법에 이의를 제기할 수 있음.
    - 각 마이크로 서비스가 독자적인 DB를 갖춰야하는 것으로 생각하고 있을 수 있기 때문임
    - 하지만, 이런 접근은 다양한 데이터 일관성 문제를 낳을 수 있음
    - 논리적으로 하나의 원자적 연산이 여러 DB에 걸쳐 실행되는 일을 피할 수 없게 됨
      - 하나의 트랜잭션으로 데이터 일관성을 보증하는 기법을 사용할 수 없다는 뜻임
      - 예약 갱신 연산이 실패했을 때 원래 값으로 돌려야 하지만, 데이터 불일치 문제가 발생할 수 있음
        - 2단계 커밋(2PC, 2-phase commit)
          - 여러 노드에 걸친 원자적 트랜잭션을 보장하는 DB 프로토콜
          - 모든 노드가 성공하던가 실패하던가 하나로 트랜잭션이 마무리되도록 보증
          - 비중단 실행이 가능한 프로토콜이 아니라 한 노드에 장애가 발생하면 해당 장애가 복구될 때까지 진행이 중단됨.
        - 사가(saga)
          - 각 노드에 국지적으로 발생하는 트랜잭션을 하나로 엮은 것
          - 각 트랜잭션은 완료되면 다음 트랜잭션을 시작하는 트리거로 쓰일 메시지를 보냄
          - 한 트랜잭션이라도 실패 시 이전 트랜잭션 결과를 전부 되돌리는 트랜잭션들을 순차적으로 실행함.
        - 2PC는 여러 노드에 걸친 하나의 트랜잭션으로 ACID를 만족시키는 개념이고, 사가는 각 단계가 하나의 트랜잭션이라 결과적 일관성에 의존하는 것임
- MSA에서 데이터 불일치를 해결하기 위해 사용되는 복잡한 메커니즘은 시스템 전체 설계의 복잡성을 크게 증가시킴
- 증가한 복잡성이 그만한 가치가 있ㅈ는지 결정하는 것은 설계자의 몫임


## 4단계 - 마무리

---