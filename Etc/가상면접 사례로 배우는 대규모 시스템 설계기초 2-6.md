# 11장 - 결제 시스템
## 1단계 - 문제 이해 및 설계 범위 확정
- 요구 사항 분석
  - Q) 어던 결제 시스템을 만들어야 하는가?
    - A) 아마존닷컴 같은 전자상거래 애플리케이션을 위한 결제 백엔드를 구축하나독 가정. 결제 시스템은 돈의 흐름에 대한 모든 것을 처리해야 함
  - Q) 어떤 결제 방법을 지원해야 하는가? 신용 카드, 페이팔, 은행 카드 등
    - A) 결제 시슽메은 실생활에서 사용 가능한 모든 옵션을 지원해야 함. 하지만 이번에는 신용 카드 결제만 처리함
  - Q) 신용 카드 결제 처리를 직접해야 하는가?
    - A) 아님. 스트라이프, 브레인트리(Braintree), 스퀘어(Square) 같은 전문 결제 서비스 업체를 사용함
  - Q) 신용 카드 데이터를 직접 저장해야 하는가?
    - A) 보안과 법규 준수 사항이 까다로우므로 카드 번호를 직접 저장하지는 않음. 민감한 신용카드 데이터 처리는 결제 처리 업체에 의존함
  - Q) 전 세계를 대상으로 하는가? 다양한 통화와 국제 결제를 지원해야 하는지?
    - A) 좋은 질문임. 전 세계적으로 사용되;지만 이번에는 하나의 통화만 사용한다고 가정함
  - Q) 하루 몇 건의 결제가 이루어지는가?
    - A) 하루 100만 건의 거래가 이루어진다고 가정함
  - Q) 아마존과 같은 전자상거래 사이트에서 매월 판매자에게 대금을 지급하는 절차를 지원하는가?
    - A) yes
  - Q) 추가로 주의해야할 것이 있는가?
    - A) 결제 시스템은 내부 서비스(계정, 분석 등) 및 외부 서비스(결제 서비스 공급자)와 연동함.
    - 한 서비스에 장애가 발생하면 서비스 간 상태가 달라지는 상황이 벌어질 수 있고, 이에 대한 조정 작업을 수행하고 불일치한 부분을 교정해야 함.

### 기능 요구사항
- 대금 수신(pay-in) 흐름
  - 결제 시스템이 판매자를 대신해 고객으로부터 대금을 수령함
- 대금 정산(pay-out) 흐름
  - 결제 시스템이 전 세계 판매자에게 제품 판매 대금을 송금함

### 비기능 요구사항
- 신뢰성 및 내결함성
  - 결제 실패는 신중하게 처리해야 함
- 내부 서비스(결제 시스템, 회계 시스템)와 외부 서비스(결제 서비스 제공업체) 간의 조정 프로세스
  - 시스템 간의 결제 정보가 일치하는지 비동기적으로 확인

### 개략적인 규모 추정
- 하루 100만 건의 트랜잭션을 처리해야 함
  - TPS는 10
    - 100만 / 10^5초
  - 10TPS는 일반적인 DB로 별 문제 없이 처리 가능하므로 처리 대역폭 대신 결제 트랜잭션의 정확한 처리에 초점을 맞춰 진행함

## 2단계 - 개략적 설계안 제시 및 동의 구하기
- 결제 흐름은 두 단계로 세분화 됨
  - 대금 수신 흐름
    - 구매자가 주분하면 아마존 은행 계좌로 돈이 들어오는 것
  - 대금 정산 흐름
    - 판매 완료 후 제품이 배송된 후에는 계좌에 있던 판매 대금에서 수수료를 제외한 잔액이 판매자의 은행 계좌로 지급됨

### 대금 수신 흐름 - 결제 서비스
- 사용자로부터 결제 이벤트를 수락하고 결제 프로세스를 조율함.
- 일반적으로 가장 먼저하는 것은 AML/CFT같은 규정을 준수하는지, 자금 세탁이나 테러 자금 조달과 같은 범죄 행위 증거가 없는지 평가하는 위험 점검임
  - 위험 확인 서비스는 매우 복잡하고 고도로 전문화되어 있어 제 3자 제공 업체를 이용함

### 결제 실행자
- 결제 실행자는 결제 서비스 공급자(PSP)를 토해 결제 주문 하나를 실행함
  - 하나의 결제 이벤트에는 여러 결제 주문이 포함될 수 있음

### 결제 서비스 공급자(PSP, Payment Service Provider)
- PSP는 A 계쩡에서 B 계정으로 돈을 옮기는 역할을 담당함

### 원장
- 원장은 결제 트랜잭션에 대한 금융 기록임
  - 사용자가 판매자에게 1달러를 결제하면 사용자로부터 1달러를 인출하고 판매자에게 1달러를 지급하는 기록을 남김
  - 원장 시스템은 전자상거래 웹 사이트의 총 수익을 계산하거나 향후 수익을 예측한느 등 결제 후 분석에서 매우 중요한 역할을 함

### 지갑
- 지갑은 판매자의 계정 잔액을 관리함
- 특정 사용자가 결제한 총 금액을 기록할 수도 있음
- 일반적인 결제 흐름
  - 사용자가 '주문하기' 버튼을 클릭하면 결제 이벤트가 생성되어 결제 서비스로 전송됨
  - 결제 서비스는 결제 이벤트를 DB에 저장함
  - 때로는 단일 결제 이벤트에 여러 결제 주문이 포함될 수 있음
    - 한 번 결제로 여러 판매자의 제품을 처리하는 경우 등
    - 웹사이트에서 한 결제를 여러 결제 주문으로 분할하는 경우, 결제 서비스는 결제 주문마다 결제 실행자를 호출함
  - 결제 실행자는 결제 주문을 DB에 저장함
  - 결제 실행자가 외부 PSP를 호출해 신용 카드 결제를 처리함
  - 결제 실행자가 결제를 성공적으로 처리하고 나면 결제 서비스는 지갑을 갱신해 특정 판매자의 잔고를 기록함
  - 지갑 서버는 갱신되고 잔고 정보를 DB에 저장함
  - 지갑 서비스가 판매자 잔고를 성공적으로 갱신하면 결제 서비스는 원장을 호출함
  - 원장 서비스는 새 원장 정보를 DB에 추가함

### 결제 서비스 API - POST /v1/payments
- 하나의 결제 이벤트에 여러 결제 주문이 포함될 수 있음

| 필드 | 설명 | 자료형    |
|------|------|--------|
| buyer_id | 구매자 정보 | json   |
| checkout_id | 해당 결제 이벤트를 식별하는 전역적으로 고유한 ID | string |
| credit_card_info | 암호화된 신용 카드 정보 또는 결제 토큰. PSP마다 다른 값 | json |
| payment_orders | 결제 주문 목록 | list |

- payment_orders

| 필드 | 설명                       | 자료형               |
|-----|--------------------------|-------------------|
| seller_account | 대금을 수령할 판매자              | string            |
| amount | 해당 주문으로 전송되어야 할 금액       | string            |
| currency | 주문에 사용된 통화 단위            | string (ISO 4217) |
| payment_order_id | 해당 주문을 식별하는 전역적으로 고유한 ID | string            |

- payment_order_id가 전역적으로 고유한 ID라는 것에 주의해야 함
- 결제 실행자가 타사 PSP에 결제 요청을 전송할 때, PSP는 payment_order_id를 중복 제거 ID로 사용함(멱등 키라고도 함)
- amount의 데이터 유형이 double이 아닌 이유
  - 프로토콜, 소프트웨어, 하드웨어에 따라 직렬화/역직렬화에 사용하는 숫자 정밀도가 다를 수 있음
    - 이는 의도치 않은 반올림 오류가 발생할 수 있음
  - 이 숫자가 매우 클 수도 있고, 매우 작을 수도 있음
  - 저장은 string으로 하고, 계산 시 숫자로 변환함

### 결제 서비스 API - GET /v1/payments/{:id}
- payment_order_id가 가리키는 단일 결제 주문의 실행 상태를 반환함

### 결제 서비스 데이터 모델
- 결제 서비스는 결제 입네트와 결제 주문의 두 개 테이블이 필요함.
- 결제 시스템용 저장소 솔루션을 고를 때 일반적으로 성능은 중요한 고려 사항이 아님
  - 안정성이 검증되었는가?
  - 다른 대형 금융사에서 수년 동안 긍정적인 피드백을 받으며 사용된 적이 있는가?
  - 모니터링 및 데이터 탐사(investigation) 도구가 있는가?
  - 숙련된 DBA를 쉽게 채용할 수 있는가?
- NoSQL/NewSQL보다는 ACID 트랜잭션을 지원하는 전통적은 RDB를 선호함
- 결제 이벤트

| 이름          | 자료형            |
|-------------|----------------|
| checkout_id | string PK      |
| buyer_info  | string         |
| seller_info | string         |
| credit_card_info | 카드 제공업체에 따라 다름 |
| is_payment_done | boolean        |

- 결제 주문

| 이름 | 자료형 |
|------|--------|
| payment_order_id | string PK |
| buyer_account | string |
| amount | string |
| currency | string |
| checkout_id | string FK |
| payment_order_status | string |
| ledger_updated | boolean |
| wallet_updated | boolean |

- checkout_id는 외래 키임
  - 한 번의 결제 행위는 하나의 결제 이벤트를 만들고, 하나의 결제 이벤트는 여러 개의 결제 주문이 포함될 수 있음
- 구매자의 신용 카드에서 금액을 공제하기 위해 타사 PSP를 호출하면 판매자가 대신 전자상거래 웹사이트의 은행 계좌에 이체가 이루어지는데, 이를 대금 수신이라 부름
  - 제품이 배송되는 등 대금 정산 조건 충족 시 해당 대금을 판매자에게 정산하는 절차를 시작함.
    - 따라서 사용자의 결제를 처리하는 중에는 판매자의 계좌가 아니라 구매자의 카드 정보만 필요함
- 결제 주문 테이블에서 payment_order_status는 결제 주문의 실행 상태를 유지하는 열거 자료형임
  - NOT_STARTED, EXECUTING, SUCCESS, FAILED 등이 있음
  - 업데이트 로직
    - payment_order_status의 초깃값은 NOT_STARTED임
    - 결제 서비스는 결제 실행자에 주문을 전송하면 payment_order_status의 값을 EXECUTING로 변경함
    - 결제 서비스는 결제 처리자의 응답에 따라 payment_order_status의 값을 SUCCESS 또는 FAILED로 변경함
  - SUCCESS 상태가 되면 결제 서비스는 지갑 서비스를 호출해 판매자의 잔액을 업데이트하고 wallet_updated를 true로 설정함
  - 이 절차 이후 다음 단계로 원장 서비스를 호출해 원장 DB의 ledger_updated를 true로 설정함
  - 동일한 checkout_id 아래 모든 결제 주문이 성공적으로 처리되면 결제 서비스는 결제 이벤트 테이블의 is_payment_done을 true로 설정함
  - 일반적으로 종결되지 않은 결제 주문을 모니터링하기 위해 주기적으로 실행되는 scheduled job을 마련해둠

### 복식부기 원장 시스템
- 복식부기(double-entry)는 원장 시스템에서 아주 중요한 설계 원칙임
  - 복식부기 회계(accounting)/부기(bookeeping)라고도 함
- 모든 결제 시스템에 필수 요소이며, 정확한 기록을 남기는 데 핵심적 역할을 함
- 모든 결제 거래를 두 개의 별도 원장 계좌에 같은 금액으로 기록함. 한 쪽에선 차감, 다른 한 쪽에서는 입긍미 이루어짐
- 복식부기 시스템에서 모든 거래 항목의 합계는 0이어야 함
- 이 시스템을 활용해 자금 흐름의 처음부터 끝을 추적할 수 있고, 결제 주기 전반에 걸쳐 일관성을 보장할 수 있다.

### 외부 결제 페이지
- 대부분의 기업은 복잡한 규정 때문에 신용 카드 정보를 내부에 저장하지 않는다.
  - 이를 위해서 PSP에서 제공하는 외부 신용 카드 페이지를 사용함
  - 웹사이트에서는 위젯 또는 iframe이고, 모바일에서는 결제 SDK가 포함된 사전에 구현된 페이지다.

### 대금 정산 흐름
- 대금 정산 흐름의 구성 요소는 대금 수신 흐름과 아주 유사함.
- 한 가지 차이는 PSP를 사용해 구매자의 신용 카드에서 전자상거래 웹사이트 은행으로 이체하는 대신, 정산 흐름에서는 타사 정산 서비스를 사용해 전자상거래 웹사이트 은행 계좌에서 판매자 은행 계좌로 돈을 이체한다는 점임

## 3단계 - 상세 설계

### PSP 연동
- 결제 시스템이 은행이나 비자 또는 마스터카드같은 카드 시스템에 직접 연결할 수 있으면 PSP 없이도 결제가 가능함
- 일반적으로 직접 연결에 투자할 수 있는 것은 아주 큰 회사 뿐임
- 일반적인 결제 시스템과 PSP 연동 방법
  - 회사가 민감한 결제 정보를 안전하게 저장할 수 있으면 API를 통해 PSP와 연동하는 방법을 선택할 수 있음.
    - 회사가 결제 웹페이지를 개발하고 민감한 결제 정보를 수집하며, PSP는 은행 연결, 다양한 카드 유형을 지원하는 역할을 함
  - 복합한 규정과 보안 문제로 민감한 결제 정보를 저장하지 않기로 한 경우, PSP는 카드 결제 세부 정보를 수집해 PSP에 안전하게 저장할 수 있도록 외부 결제 페이지를 제공함
    - 대부분의 기업이 선택하는 접근법임
- 간결한 전체 결제 프로세스
  - 사용자가 클라이언트 브라우저에서 '결제' 버튼을 클릭함.(클라가 결제 주문 정볼르 담아 결제 서비스를 호출함)
  - 결제 주문 정보를 수신한 결제 서비스는 결제 등록 요청(payment registration request)을 PSP에 전송함
    - 결제 금액, 통화, 결제 요청 만료일, 리디렉션 URL 등의 결제 정보가 포함됨.
    - 정확히 한 번 등록되도록 UUID 필드를 둠.
      - 일반적으로 결제 주문의 ID로 사용됨
  - PSP는 결제 서비스에 토큰을 반환함.
    - 토큰은 등록된 결제 요청을 유일하게 식별하는, PSP가 발급한 UUID임
    - 이 코튼을 이용해 결제 등록 및 결제 실행 상태를 확인함
  - 결제 서비스는 PSP가 제공하는 외부 결제 페이지를 호추하기 전에 토큰을 DB에 저장
  - 토큰을 저장하고 나면 클라는 PSP가 제공하는 외부 결제 페이지를 표시함.
    - 애플리케이션은 일반적으로 이를 위해 PSP SDK를 연동함
    - 민감한 결제 정보는 PSP가 수집
    - 외부 결제 페이지가 필요한 정보
      - 4단계에서 받은 토큰
        - PSP의 JS는 이 토큰을 사용해 PSP의 백엔드에서 결제 요청에 대한 상세 정보를 검색함
        - 이 과정에서 사용자에게 받을 금액은 중요한 정보 중 하나임
      - 리디렉션 URL
        - 결제가 완료되면 호출될 URL
        - PSP의 JS는 결제가 완료되면 브라우저를 리디렉션 URL로 보냄
        - 일반적으로 리디렉션 URL은 결제 상태를 표시하는 웹 사이트 상의 한 페이지임
        - 웹훅 URL과는 다르다는 것을 알아야 함
  - 사용자는 카드 번호, 소유자 이름 등의 결제 세부 정보를 PSP의 웹 페이지에 입력하고 결제를 요청함
  - PSP가 결제 상태를 반환함
  - 리디렉션 URL이 가리키는 웹 페이지로 보내짐
    - 보통 7단계에서 수신된 결제 상태가 URL에 추가됨
      - host_url/?tokenId={tokenId}&payResult={payResult}
  - 비동기적으로 PSP는 웹훅을 통해 결제 상태와 함께 결제 서비스를 호출함
    - 웹훅은 결제 시스템 측에서 PSP를 처음 설정할 때 등록한 URL임
    - 결제 시스템이 웹훅을 통해 결제 이벤트를 다시 수신하면 결제 상태를 추출해 결제 주문 DB의 payment_order_status를 업데이트함

### 조정
- 위 9단계 중 네트워크 등으로 장애 발생 시 처리하는 방법
- 조정이란 관련 서비스 간의 상태를 주기적으로 비교해 일치하는지 확인하는 것
- 매일 밤 PSP나 은행은 고객에게 정산 파일을 보냄.
  - 은핵 계좌의 잔액과 하루 동안 해당 계좌에서 발생한 모든 거래(transaction) 내역이 기재됨
- 조정 시스템은 정산 파일의 세부 정보를 읽어 원장 시스템과 비교함
- 조정은 결제 시스템의 내부 일관성을 확인할 때에도 사용됨
  - 원장과 지갑 상태가 같은지 등에서도 사용됨
- 발생 가능한 불일치 문제 및 해결 방안
  - 어떤 유형의 문제인지 알고 문제 해결 절차를 자동화할 수 있는 경우
    - 원인과 해결 방법을 알고 있고, 자동화하는 것이 비용 효율적인 경우.
    - 불일치 문제의 분류와 조정 작업을 모두 자동화 가능
  - 문제는 알지만 해결 절차를 자동화할 수 없는 경우
    - 불일치의 원인과 해결 방법은 알지만 자동화하는 비용이 너무 높을 때
    - 작업 대기열에 넣고 재무팀에서 수동으로 조정하도록 함
  - 분류할 수 없는 유형의 문제인 경우
    - 불일치가 어떻게 발생했는지 알지 못하는 경우
    - 이런 경우 특별 작업 대기열에 넣고 재무팀에서 조사하도록 함

### 결제 지연 처리
- 대부분 몇 초 안에 처리되지만, 완료/거부까지 몇 시간 또는 며칠이 걸리는 경우가 있음
  - PSP가 해당 결제 요청의 위험성이 높다고 판단해 담당자 검토를 요구하는 경우
  - 신용 카드사가 구매 확인 용도로 카드 소유자의 추가 정보를 요청하는 3D 보안 인증 같은 추가 보호 장치를 요구하는 경우
- 구매 페이지가 외부 PSP에 호스팅 되는 경우
  - PSP는 결제가 대기 상태에 있음을 클라이언트에 알리고, 클라이언트가 사용자에게 표시함
  - PSP는 대기 중인 결제 진행 상황을 추적하고 상태가 바뀌면 PSP에 등록된 웹훅을 통해 결제 서비스에 알림
  - 결제 요청이 완료되면 PSP는 웹훅을 호출함.
  - 이후 결제 서비스는 내부 시스템에 정보를 업데이트함

### 내부 서비스 간 커뮤니케이션 - 동기식 통신
- HTTP 같은 통신은 소규모 시스템에서는 잘 동작하지만, 규모가 커지면 단점이 명확해짐
- 성능 저하
  - 요청 처리에 관계된 서비스 하나의 성능 문제가 전체 시스템에 영향을 줌
- 장애 격리 곤란
  - PSP 등의 서비스에 장애 발생 시 클라이언트는 더 이상 응답을 받지 못 함
- 높은 결합도
  - 요청 발신자는 수신자를 알아야 함
- 낮은 확장성
  - 큐를 버퍼로 사용하지 않고는 갑작스러운 트래픽 증가에 대응할 수 있게 시스템 확장이 어려움

### 내부 서비스 간 커뮤니케이션 - 비동기 통신
- 단일 수신자
  - 각 요청(메시지)은 하나의 수신자 또는 서비스가 처리함
  - 일반적으로 공유 메시지 큐를 사용해 구현함
  - 큐에는 여러 구독자가 있을 수 있지만, 처리된 메시지는 큐에서 바로 제거됨
- 다중 수신자
  - 각 요청(메시지)은 여러 수신자나 서버가 처리함
  - 카프카가 이런 시나리오를 잘 처리함
  - 소비자가 수신한 메시지는 카프카에서 바로 사라지지 않음
  - 동일한 메시지를 여러 서비스가 받아서 사용할 수 있으므로 결제 시스템 구현에 적합함
    - 하나의 요청을 푸시 알림 전송, 재무 보고 업데이트, 분석 결과 업데이트 등 다양한 용도로 사용 가능
- 동기식 통신은 설계하기 쉽지만, 서비스의 자율성을 높이기에는 적합하지 않음.
- 의존성 그래프가 커지면 전반적인 성능이 낮아짐
- 비동기는 설계의 단순성과 데이터 일관성을 시스템 확장성 및 장애 감내 능력과 맞바꾸는 결과임
- 비즈니스 로직이 복잡하고 타사 서비스 의존성이 높은 대규모 결제 시스템에서는 비동기 통신이 더 나은 선택임

### 결제 실패 처리 - 결제 상태 추적
- 결제 실패 처리에서 결제 상태를 정확하게 유지하는 것은 매우 중요한 요구사항임
- 실패가 발생할 때마다 결제의 현재 상태를 파악하고 재시도 또는 환불 여부 등을 결정함
- 결제 상태는 데이터 추가만 가능한 DB 테이블에 보관함

### 결제 실패 처리 - 재시도 큐 및 실패 메시지 큐
- 실패를 우아하게 처리하기 위해서는 재시도 큐와 실패 메시지 큐를 두는 것이 바람직 함
- 재시도 큐
  - 일시적 오류 같은 재시도 가능 오류는 재시도 큐에 보냄
- 실패 메시지 큐
  - 반복적으로 처리 실패한 메시지는 결국 실패 메시지 큐로 보냄
  - 문제가 잇는 메시지를 디버깅하고 격리해 성공적으로 처리되지 않은 이유를 파악하는 데 유용함
- 재시도 가능한지 확인
  - a) 재시도 가능 실패는 재시도 큐로 보냄
  - b) 잘못된 입력과 같이 재시도가 불가능한 실패는 오류 내역을 DB에 저장함
- 결제 시스템은 재시도 큐에 쌓인 이벤트를 읽어 실패한 결제를 재시도함
- 결제 거래가 다시 실패하는 경우에는 다음과 같이 처리함
  - a) 재시도 횟수가 임계값 이내일 경우 해당 이벤트를 다시 재시도 큐로 보냄
  - b) 재시도 횟수가 임계값을 넘으면 해당 이벤트를 실패 메시지 큐에 넣음.(별도 조사가 필요할 수도 있음)

### 정확히 한 번 전달
- 결제 시스템에서 가장 큰 문제는 이중 청구다
- 따라서 결제 주문이 정확하게 한 번만 실행되는 것이 아주 중요하다
- 메시지를 정확히 한 번 전달하는 것은 매우 어려워 보이지만, 문제를 두 부분으로 나누면 훨씬 쉬워진다.
  - 최소 한 번 실행된다.
    - 재시도를 통해 최소 한 번 실행을 보증 가능함
  - 최대 한 번 실행된다.
    - 멱등성 검사를 통해 최대 한 번 실행을 보증 가능함

### 정확히 한 번 전달 - 재시도
- 네트워크 오류 등으로 결제 거래를 다시 시도해야 하는 경우가 있음.
- 재시도 메커니즘을 통해 최소 한 번 결제가 실행되도록 보장이 가능함
- 재시도 간격
  - 즉시 재시도
    - 클라이언트는 즉시 다시 요청을 보냄
  - 고정 간격
    - 재시도 전 일정 시간을 기다림
  - 증분 간격
    - 재시도 전 기다리는 시간을 특정 양 만큼 점진적으로 늘려감
  - 지수적 백오프
    - 재시도 전 기다리는 시간을 직전 재시도 시간의 두 배로 늘림
  - 취소
    - 요청을 철회하는 방법
    - 실패가 영구적이거나 재시도해도 성공 가능성이 낮을 때 흔히 사용됨
- 네트워크 문제가 단기간에 해결될 것 같지 않다면 지수적 백오프가 유용함.
  - 에러 코드를 반환할 땐 Retry-After 레더를 같이 붙여 보내는 것이 바람직 함
- 재시도 시 발생할 수 있는 잠재적 문제는 이중 결지임
  - 시나리오 1
    - 결제 시스템이 외부 결제 페이지를 통해 PSP와 연동하는 환경에서 클라이언트가 결제 버튼을 두 번 중복 클릭
  - 시나리오 2
    - PSP가 결제를 성공했으나 네트워크 오류로 응답이 결제 시스템에 도달하지 못 해 사용자나 클라이언트가 결제를 다시 시도함

### 정확히 한 번 전달 - 멱등성
- 멱등성은 연산을 여러번 실행해도 같은 결과가 그대로 보존되는 특성을 말함
- 클라이언트가 생성한 UUID를 멱등 키로 권장하며, 헤더에 멱등키를 추가해 결제 요청의 멱등성을 보장함
- 시나리오 1 : 고객이 '결제'버튼을 빠르게 두 번 클릭하는 경우
  - 사용자가 결제 클릭 시 멱등 키가 HTTP 요청의 일부로 함께 결제 시스템에 전송됨
  - 일반적으로 전자상거래에서 멱등 키는 결제가 이루어지기 직전의 장바구니 ID다
  - 결제 시스템은 두 번째 요청을 재시도로 처리함.
    - 이전에 멱등 키를 받은 적이 있기 때문임.
    - 이럴 땐 이전 결제 요청의 가장 최근 상태를 반환함
  - 멱등성을 지원하는 한 가지 방법은 DB의 고유 키 제약 조건을 활용하는 것이다.
    - DB 테이블의 기본 키를 멱등 키로 사용하는 경우와 같다
      - 결제 시스템은 결제 요청을 DB에 저장하려고 함
      - 새 레코드 추가에 성공한다는 것은 이전에 처리한 적 없는 요청이라는 뜻임
      - 새 레코드 추가에 실패했다는 것은 이전에 받은 요청이므로 중복 요청은 처리하지 않음
- 시나리오 2 : PSP가 결제를 성공적으로 처리했찌만 네트워크 오류로 응답이 결제 시스템에 전달되지 못해 사용자가 버튼을 다시 누르는 경우
  - 결제 서비스는 PSP에 비중복 난수를 전송하고 PSP는 해당 난수에 대응하는 토큰을 반환함
  - 난수는 결제 주문을 유일하게 식별하고, 토큰은 난수에 1:1 대응함
  - 따라서 토큰도 결제 주문을 유일하게 식별 가능함
  - 결제 버튼을 다시 눌러도 결제 주문이 같으므로 PSP로 전송되는 토큰도 같음

### 일관성
- 결제 과정에서 결제 상태 정보를 유지하는 여러 서비스가 호출됨
  - 결제 서비스는 비중복 난수, 토큰, 결제 주문, 실행 상태 등의 결제 관련 데이터를 유지함
  - 원장은 모든 회계 데이터를 보관
  - 지갑은 판매자의 계정 잔액을 유지
  - PSP는 결제 실행 상태를 유지
  - 데이터는 안정성을 높이기 위해 여러 DB 사본에 복제될 수 있음
- 분산 환경에서는 서비스 간 통신 실패로 데이터 불일치가 발생할 수 있고, 내부 서비스 간에 데이터 일관성을 유지하기 위해선 '**정확히 한 번 처리**'가 중요함
- 내부 서비스와 외부 서비스(PSP) 간의 데이터 일관성 유지를 위해서는 일반적으로 멱등성과 조정 프로세스를 활용함
- 외부 서비스가 멱등 API를 지원해도 항상 옳다고 가정할 수 없으므로 조정 절차를 생략할 수는 없음
- DB를 다중화했을 경우에는 복제 지연으로 주-사본 데이터 불일치가 발생할 수 있음
  - 주 DB로만 읽기와 쓰기 연산 처리
    - 규모 확장성이 떨어지고, 사본이 데이터 안정성 보장에만 사용되므로 낭비됨
  - 모든 사본이 항상 동기화되도록함
    - 팩서스(Paxos), 래프트(Raft) 같은 합의 알고리즘을 사용하거나 YugabyteDB, CockoachDB같은 합의 기반 분산 DB를 사용함

### 결제 보안
- 문제 : 요청/응답 도청
  - 해결 : HTTPS 사용
- 문제 : 결제 정보 변조
  - 해결 : 암호화 및 무결성 강화 모니터링
- 문제 : 중간자 공격
  - 해결 : 인증서 고정과 함께 SSL 사용
- 문제 : 데이터 손실
  - 해결 : 여러 지역에 걸쳐 DB 복제 및 스냅샷 생성
- 문제 : 분산 서비스 거부 공격(DDoS)
  - 해결 : 처리율 제한 및 방화벽
- 문제 : 카드 도난
  - 해결 : 토큰화, 실제 카드 번호 대신 토큰을 저장하고 결제에 사용
- 문제 : PCI 규정 준수
  - 해결 : PCI DSS는 브랜드 신용 카드를 처리하는 조직을 위한 정보 보안 표준
- 문제 : 사기
  - 해결 : 주소 확인, 카드 확인 번호, 사용자 행동 분석 등


### Q) 결제 상태를 데이터 추가만 가능한 DB 테이블에 보관하는 이유는?
- 결제 상태를 업데이트 할 일이 없을 것이다.
- 이벤트 소싱...
- 정합성 체크를 할 때
  - 업데이트가 되면 정합성 체크를 할 수 없게 됨.
- 방어적 복사 느낌
  - 다른 상태의 객체가 필요할 때 새로운 객체를 생성해서 사용하는 것처럼 원본 데이터를 놔두고 싶었던 것 아닐까

### Q) 결제 정상 상태라는 것을 체크하는 방법은 무엇일까?
- PSP 금액과 요청한 결제 금액이 같지 않을 때
- 시스템 상에는 결제 완료되었으나, PSP에서는 결제가 완료되지 않았을 때
  - 코드단에서 동기적으로 처리해서 PSP가 완료되었을 때만 처리하면 어떤가?
    - PSP에서의 오류가 우리 시스템에도 영향을 줄 수 있음.
  - 최종 결제 완료 처리 전 1회 더 PSP에 확인해본다
  - 사용자가 우리 시스템을 통한 환불이 아니라, PSP를 통해 환불을 요청했을 때
    - 환불이 완료되면 우리 시스템에 다시 알려줘야 함
    - 이건 웹훅으로 처리하면 될 것 같음
- 그 외 결제 관련 엣지 케이스

### Q) 임계값이 넘은 메시지를 실패 메시지 큐를 사용해 분리하는 이유는?
- 영속적으로 저장하는 것이 아니라 다시 '메시지 큐'에 넣는 이유는?
- 우선 메시지 큐와 실패 메시지 큐를 분리하는 이유는?
  - 두 메시지의 성향이 달라졌고, 소비자도 달라지게 되었기 때문임.
  - 서로 다른 처리 과정을 거치는 데이터가 되었기 때문임.
- 실패한 메시지들을 메시지 큐에 넣어서 이후에 알아서 처리하도록 할 수 있음.
  - DB에 영속적으로 저장하던가, 로그 시스템에 던지던가 이런 것들을 할 수 있음

---
# 12장 - 전자 지갑
- 전자 지갑에 돈을 이체해두면 이를 사용한 결제가 가능함
- 전자 지갑 간의 이체는 은행 간 이체보다 빠르고, 일반적으로 추가 수수료가 붙지 않는다는 장점이 있음

## 1단계 - 문제 이해 및 설계 범위 확정
- Q) 두 전자 지갑 사이 이체에만 집중하는가? 다른 기능은?
  - A) 이체 기능에만 집중함
- Q) 시스템이 지원해야 하는 초당 트랜잭션 수(TPS)는?
  - A) 1_000_000 TPS로 가정
- Q) 전자 지갑 정확성에 대한 요건은? DB가 제공하는 트랜잭션 보증이면 충분한가?
  - A) 좋음
- Q) 정확성을 증명해야 하는가?
  - A) 일반적으로 정확성은 트랜잭션이 완료된 뒤에나 확인할 수 있음.
  - 한 가지 검증 방법은 내부 기록과 은행의 명세서를 비교하는 것임.
  - ㅁ그러나, 이런 조정 작업으로는 데이터 일관성이 깨진 것은 알 수 있지만 이유를 알기는 힘듦
  - 따라서 재현성을 갖춘 시스템을 설계하고자 함.
  - 처음부터 데이터를 재생해 언제든지 과거 잔액을 재구성할 수 있는 시스템을 만들고자 함
- Q) 가용성 요구 사항이 99.99%라고 가정해도 되는가?
  - A) 좋음
- Q) 환전이 가능해야 하는가?
  - A) 전자 지갑 간 이체
- 1_000_000 TPS
- 99.99% 안정성
- 트랜잭션
- 재현성

### 개략적 추정
- TPS를 언급한다는 것은 배후에 트랜잭션 기반 DB를 사용한다는 뜻임
- RDB는 초당 수천 건의 트랜잭션을 지원할 수 있음
- DB 노드 당 1000 TPS를 지원한다고 가정하면 2000대의 DB 노드가 필요함
  - 인출 100만건, 입금 100만건
- 따라서 이번 장에서 중요 목표 중 하나는 단일 노드가 처리할 수 있는 트랜잭션 수를 늘리는 것임

## 2단계 - 개략적 설계안 제시 및 동의 구하기
- API 설계
- 세 가지 개략적 설계안
  - 간단한 메모리 기반 솔루션
  - DB 기반 분산 트랜잭션 솔루션
  - 재현성을 갖춘 이벤트 소싱(event sourcing) 솔루션

### API 설계
- 하나의 API만 구비하면 됨
  - POST /v1/wallet/balance_transfer
    - 한 지급에서 다른 지갑으로 자금 이체
  - 요청 인자
    - from_account(string) : 자금을 인출할 계쫘
    - to_account(string) : 자금을 입금할 계좌
    - amount(string) : 이체할 금액
    - currency(string, ISO 4217) : 통화 단위
    - transaction_id(uuid) : 중복 제거(deduplication)에 사용할 ID
  - 응답 예시

```json
{
  "status": "success",
  "transaction_id": "uuid"
}
```

- amount 필드는 double이 아니라 string으로 사용함.
  - double은 부동 소수점 연산을 사용하므로 정확한 금액을 표현할 수 없음

### 인메모리 샤딩
- 지갑 애플리케이션은 모든 사용자 계정의 잔액을 유지함
- <사용자, 잔액> 관계로 이루어 지기에 해시 테이블, Map, Key-Value 저장소를 사용하면 좋음
- 레디스는 인메모리 저장소로 인기 있는 선택지 중 하나임
  - 하지만, 레디스 노드 한 대로 100만 TPS 처리는 벅참
  - 파티셔닝, 샤딩이 필요함
    - 클러스터를 구성하고 사용자 계정을 모든 노드에 균등하게 분산시켜야 함
    - 모든 레디스 노드의 파티션 수 및 주소는 한 군데 저장해둠.
    - 높은 가용성을 보장하는 설정 정보 전문 저장소 주키퍼가 이 용도로 좋음
- 지갑 서비스
  - 이체 명령 수신
  - 이체 명령의 유효성 검증
  - 명령이 유효할 경우 이체 관계의 두 계정 잔액을 갱신
    - 두 계정은 서로 다른 레디스 노드에 있을 수 있음
- 해당 설계에서 계정 잔액은 여러 레디스 노드에 분산됨. 주키퍼는 샤딩 정보 관리에 사용하고, 무상태 서비스인 지갑 서비스는 주키퍼에 샤딩 정보를 질의해 특정 클라이언트의 정보를 담은 레디스 노드를 찾고 그 잔액을 적절히 갱신함
  - 이 설계는 작동하지만 정확성 요구 사항을 충족하지 못 함.
  - 지갑 서비스는 이체할 때마다 두 레디스를 업데이트 하는데, 모두 성공하리라는 보장이 없음.
  - 두 업데이트 연산이 하나의 원자적 트랜잭션으로 실행되어야 함

### 분산 트랜잭션 - DB 샤딩
- 각 레디스 노드를 RDB 노드로 교체
  - 인메모리 샤딩과 같은 방식으로 가면 일부 문제만 해결됨.

### 분산 트랜잭션 - 2단계 커밋(2PC)
- 분산 시스템에서 한 트랜잭션에는 여러 노드의 프로세스가 관여할 수 있음
- 분산 트랜잭션은 이런 프로세스를 원자적인 하나의 트랜잭션으로 묶는 방안임
- 저수준 방안
  - DB 자체에 의존하는 방안
  - 가장 일반적으로 사요되는 2단계 커밋임
  - a) 조정자(지갑 서비스)는 정상적으로 여러 DB에 읽기/쓰기 작업을 수행, DB에는 락이 걸림
  - b) 애플리케이션이 트랜잭션을 커밋하려할 때 조정자는 모든 DB에 트랜잭션 준비를 요청함
  - c) 두 번째 단계에서 조정자는 모든 DB의 응답을 받아 다음 절차를 수행
    - 모든 DB가 '예'라고 응답하면 조정자는 모든 DB에 해당 트랜잭션 커밋을 요청
    - 어느 한 DB라도 '아니오'라고 응답하면 조정자는 모든 DB에 트랜잭션 중단을 요청함
  - 이 방법이 저수준인 이유는 준비 단계(b)를 실행하려면 DB 트랜잭션 실행 방식을 변경해야 하기 때문임
  - 해당 방법은 락이 오랫동안 잠길 수 있다는 단점이 있다.

### 분산 트랜잭션 : TC/C
- TC/c(시도-확정/취소, Try-confirm/Cancel)은 두 단계로 구성된 보상 트랜잭션임
  - a) 조정자는 모든 DB에 트랜잭션에 필요한 자원 예약을 요청
  - b) 조정자는 모든 DB로부터 회신을 받음
    - 시도-확정(Try-Confirm) 절차
      - 모두 '예'라고 응답하면 모든 DB에 작업 확인을 요청
    - 시도-취소(Try-Cancel) 절차
      - 어느 한 DB라도 '아니오'라고 응답하면 모든 DB에 작업 취소를 요청함
- 2PC는 두 단계의 한 트랜잭션이지만, TC/C에서는 각 단계가 별도의 트랜잭션이라는 점에 유의

### TC/C 사례
<table>
  <thead>
    <tr>
      <th>단계</th>
      <th>실행연산</th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>시도</td>
      <td>잔액 변경 : -1</td>
      <td>아무것도 하지 않음</td>
    </tr>
    <tr>
      <td rowspan="2">2</td>
      <td>확인</td>
      <td>아무것도 하지 않음</td>
      <td>잔액 변경 : +1</td>
    </tr>
    <tr>
      <!-- 단계는 병합했으므로 td 없음 -->
      <td>취소</td>
      <td>잔액 변경 : +1</td>
      <td>아무것도 하지 않음</td>
    </tr>
  </tbody>
</table>

- 지갑 서비스가 TC/C의 조정자라고 가정하고, 분산 트랜잭션이 시작될 때 계정 A의 잔액은 1달러고 계정 C의 잔액은 0달러임
- 1단계 - 시도
  - 시도 단계에서는조정자 역할을 하는 지갑 서비스가 두 개의 트랜잭션 명령을 두 DB로 전송함
    - a) 조정자는 계정 A가 포함된 DB에 A의 잔액을 1달러 감소시키는 트랜잭션을 시작
    - b) 조정자는 계정 C가 포함된 DB에는 아무 작업도 하지 않음. 조정자가 DB에 NOP 명령을 보낸다고 가정. DB는 NOP 명령에 대해 아무 작업도 수행하지 않고 항상 성공했다는 응답을 보냄
- 2단계 - 확정
  - 두 DB가 모두 Yes라고 하면 지갑 서비스는 확정 단계를 시작함
  - 계정 A의 잔액은 이미 첫 단계에서 갱신됨. 따라서 확인 단계에서 지갑 서비스는 계정 C에게 1달러를 추가해야 함
- 2단계 - 취소
  - 첫 번째 시도 단계가 실패할 수 있음
  - 계정 C가 불법 계정이거나 하면 취소해야함.
  - 이런 경우 A에게 다시 1달러를 추가하는 또다른 트랜잭션을 시작함
    - 계정 C의 잔액은 업데이트하지 않았으므로 NOP 명령만 전송하면 됨

### 2단계 커밋 vs TC/C
| -  | 첫 번째 단계                              | 두 번째 단계 - 성공 | 두 번째 단계 - 실패 |
|----|--------------------------------------|--------------|--------------|
| 2PC | 로컬 트랜잭션은 아직 완료되지 않은 상태 | 모든 로컬 트랜잭션을 커밋 | 모든 로컬 트랜잭션을 취소 |
| TC/C | 모든 로컬 트랜잭션이 커밋되거나 취소된 상태로 종료         | 필요한 경우 새 로컬 트랜잭션 실행 | 이미 커밋된 트랜잭션의 실행 결과를 되돌림(undo) |

- 2PC에서는 두 번째 단계가 시작될 때 모든 로컬 트랜잭션이 완료되지 않은 상태로 락도 여전히 잠겨 있음
  - 두 번째 단계에서 미완성 트랜잭션을 중단하거나 커밋해 끝냄
- TC/C에서는 두 번째 단계가 시작될 때 모든 로컬 트랜잭션이 완료된 상태로 락도 풀린 상태다.
  - 오류 발생 시 이전 트랜잭션 결과를 상쇄하는 새로운 트랜잭션을 실행함
- TC/C는 보상 기반 분산 트랜잭션이라고도 부름
  - 비즈니스 로직으로 구현하기 때문에 고수준의 해법임
  - 트랜잭션을 지원하기만 하면 DB에 구애받지 않는다는 장점이 있다
  - 단점은 애플리케이션 계층의 비즈니스 로직에서 세부 사항을 관리하고 분산 트랜잭션의 복잡성을 처리해야 한다는 것임

### 단계별 상태 테이블
- TC/C 실행 중 지갑 서비스가 다시 시작될 경우 과거 모든 작업 기록이 사라질 수 있고, 어떻게 복구해야 할 지 알 수 없게 될 수 있다.
  - TC/C의 진행 상황, 특히 각 단계 상태 정보를 트랜잭션 DB에 저장하면 됨
    - 분산 트랜잭션의 ID와 내용
    - 각 DB에 대한 '**시도**' 단계의 상태
      - not sent yet, has been sent, response received의 세 가지 값 중 하나임
    - 두 번째 단계 이름.
      - confirm, cancel 중 하나
      - 시도 단계의 결과를 사용해 계산할 수 있음
    - 두 번째 단계의 상태
    - 순서가 어긋났음을 나타내는 플래그(잘못된 순서로 실행된 경우에서 자세히 설명함)
- 단계 테이블은 일반적으로 돈을 인출할 지갑의 계정이 있는 DB에 둔다

### 불균형 상태
- 시도 단계가 끝나면 1달러가 사라진다.
  - 모든 것이 순조롭게 진행된다고 가정했을 때, 시도 단계가 끝나고 나면 계정 A에서 1달러가 차감되고 계정 C에서는 변화가 없음
    - A와 C의 합계가 0이 되어 TC/C의 시작 시점보다 작은 값이 됨. 이는 거래 후에도 잔액 총합은 동일해야 한다는 회계 기본 원칙을 위반함
    - 다행히도 트랜잭션 보증은 TC/C 방안에서도 여전히 유요함
    - TC/C는 여러 개의 독립적인 로컬 트랜잭션으로 구성됨
    - TC/C의 실행 주체는 애플리케이션이고, 애플리케이션은 이런 독립적 로컬 트랜잭션이 만드는 중간 결과를 볼 수 있음.
    - 반면 DB 트랜잭션이나 2PC같은 분산 트랜잭션은 실행 주체가 DB라서 애플리케이션이 중간 실행 결과를 알 수 없음
  - 분산 트랜잭션 실행 도중 항상 데이터 불일치가 발생함.
    - DB같은 하위에서 불일치를 수정할 땐 그 사실을 알 필요가 없지만, TC/C 같은 경우 직접 처리해야함.

### 유효한 연산 순서
- 시도 단계에서 할 수 있는 일 세 가지

| 선택지 | 계정A | 계정C |
|--------|--------|-----|
| 선택1 | -1 | NOP |
| 선택2 | NOP | +1 |
| 선택3 | -1 | +1 |

- 그럴 듯 해보이지만 일부는 유효하지 않음.
- 두 번째 선택지의 경우 계정 C 연산은 성공해도 계정 A에서 실패한 경우(NOP)  지갑 서비스는 취소 단계를 실행해야 함
  - 취소 단계에서 누군가 C 계정에서 1달러를 이미 이체했다면 남은 금액이 없어져 분산 트랜잭션의 트랜잭션 보증을 위반하게 된다
- 세 번째 선택지의 경우 1달러를 A 계좌에서 차감하고 동시에 C에 추가하면 많은 문제가 생길 수 있음
  - C에는 1달러가 추가되었지만, A에서 1달러가 차감되지 않았을 경우 등
- 따라서 1번만 유효한 방법임

### 잘못된 순서로 실행된 경우
- TC/C 에서는 실행 순서가 어긋날 수 있음
  - 시도 단계에서 계정 A에 대한 작업이 실패해 지갑 서비스에 실패를 반환한 이후 취소 단계로 진입해 계정 A와 계정 C에 취소 명령을 전송하는 경우
    - 순서가 바뀐 명령도 처리할 수 있도록 하려면 기존 로직을 수정해서 시도 명령을 받지 못한 경우에도 취소 절차를 실행할 수 있어야 함
      - 취소 명령이 먼저 도착하면 DB에 아직 상응하는 시도 명령을 못 받았음을 나타내는 플래그를 참으로 설정해 저장해둠
      - 시도 명령이 도착하면 항상 먼저 도착한 명령이 있었는지 확인하고, 있을 경우 실패를 반환함
    - "단계별 상태 테이블" 절에서 테이블 순서가 어긋난 경우를 처리하기 위한 플래그를 마련했던 이유가 이것 때문임

### 분산 트랜잭션: 사가 - 선형적 명령 수행
- 사가는 분산 트랜잭션 솔류션 중 하나로 MSA에서 사실상 표준임
- 개념
  - a) 모든 연산은 순서대로 정렬됨. 각 연산은 자신의 DB에서 독립 트랜잭션으로 실행됨
  - b) 연산은 첫 번째부터 마지막까지 순서대로 실행됨. 한 연산이 완료되면 다음 연산이 개시됨
  - c) 연산이 실패하면 전체 프로세스는 실패한 연산부터 맨 처음 연산까지 역순으로 보상 트랜잭션을 통해 롤배됨. 따라서 n개의 연산을 실행할 경우 보상 트랜잭션을 포함해 2n 개의 연산을 준비해야 함
- 연산 실행 순서 조율 방법
  - a) 분산 조율(Choreography)
    - MSA에서 사가 분산 트랜잭션과 관련된 모든 서비스가 다른 서비스의 이벤트를 구독해 작업을 수행하는 방식. 완전 탈 중앙화된 조율 방식
  - b) 중앙 집중형 조율(Orchestration)
    - 하나의 조정자가 모든 서비스가 올바른 순서로 작업을 실행하도록 조율함
  - 두 방법 중에서 사업상의 필요와 목표에 따라 결정함
  - 분산 조율 발식은 서비스가 서로 비동기적으로 통신하기 때문에 모든 서비스는 다른 서비스가 발생시킨 이벤트의 결과로 어떤 작업을 수행할지 정하기 위해 내부적으로 상태 기계(state machine)를 유지해야 함
    - 서비스가 많아지면 관리가 어려워질 수 있음
  - 일반적으로 복잡한 상황을 잘 처리하기 때문에 중앙 집중형 조율 방식을 선호한다

### TC/C vs 사가
| -  | TC/C | 사가 |
|----|------|------|
| 보상 트랜잭션 실행 | 취소 단계에서 | 롤백 단계에서 |
| 중앙 조정 | 예 | 예(중앙 집중형 조율 모드에서만) |
| 작업 실행 순서 | 임의 | 선형 |
| 병렬 실행 가능성 | 예 | 아니오(선형적 실행) |
| 일시적으로 일관되지 않은 상태 허용 | 예 | 예 |
| 구현 계층 | 애플리케이션 | 애플리케이션 |

- 실무에서는 지연 시간 요구 사항에 따라 둘 가운데 선택하는 편이다
- 사가는 순서대로 실행해야 하지만, TC/C는 병렬로 실행 가능함
- 선택에 고려할 요건
  - a) 지연 시간 요구사항이 없거나 앞서 살펴본 송금 사례처럼 서비스 수가 매우 적다면 아무거나 사용해도 됨. 일반적인 MSA에서 하는 것처럼 하고 싶으면 사가를 선택하면 됨
  - b) 지연 시간에 민감하고 많은 서비스/운영이 관계된 시스템이라면 TC/C를 선택하는 것이 좋음

### 이벤트 소싱
- 배경
  - 전자 지갑 서비스도 외부 감사를 받을 수도 있음
    - 특정 시점의 잔액을 알 수 있는지?
    - 과거 및 현재 계정 잔액을 정확히 알 수 있는지?
    - 코드 변경 후에도 시스템 로직이 올바른지 어떻게 검증하는지?
- 정의
  - 이벤트 소싱에서 중요한 네가지 용어
    - 명령(command)
    - 이벤트(event)
    - 상태(state)
    - 상태 기계(state machine)
- 명령
  - 명령은 외부에서 전달된 의도가 명확한 요청
  - 이벤트 소싱에서 순서는 아주 중요하므로 일반적으로 FIFO 큐에 저장됨
- 이벤트
  - 명령은 의도가 명확하지만 fact가 아닐 수 있어서 유효하지 않을 수 있음.
  - 이체 후 잔액이 음수가 되는 등의 유효하지 않은 명령은 실행할 수 없음.
    - 작업 실행 전 유효성 검사는 필수임
    - 검사를 통과한 명령은 반드시 이행되어야 함
  - 명령 이행 결과를 이벤트라고 부름
  - 명령 vs 이벤트
    - 이벤트는 검증된 사실로, 실행이 끝난 상태임. 따라서 이벤트를 얘기할 땐 "A에서 C로 1달러 송금이 완료됨"과 같이 과거 시제를 사용함
    - 명령에서는 무작위성(randomness)이나 I/O가 포함될수 있지만 이벤트는 정론적이다. 
  - 이벤트 생성 프로세스의 두 가지 중요한 특성
    - a) 하나의 명령으로 여러 이벤트가 만들어질 수 있다(0 이상)
    - b) 이벤트 생성과정에는 무작위성이 개입될 수 있어서, 같은 명령에 항상 동일한 이벤트가 만들어지지 않을 수 있음.
      - 이벤트 생성 과정에는 외부 I/O또는 난수가 개입할 수 있음
- 상태
  - 상태는 이벤트가 적용될 때 변경되는 내용임
  - 지갑 시스템에서 상태는 모든 클라이언트 계정의 잔액으로, 맵 형태로 표현할 수 있다
- 상태 기계
  - 이벤트 소싱 프로세스를 구동함
  - 두 가지 기능
    - a) 명령의 유형성을 검사하고 이벤트를 생성함
    - b) 이벤트를 저굥ㅇ해 상태를 갱신함
  - 이벤트 소싱을 위한 상태 기계는 결정론적으로 동작해야 함
    - 무작위성을 내포할 수 없음
      - I/O를 통해 무작위 데이터를 읽거나 난수를 사용하는 것을 허용하지 않음.
      - 이벤트를 상태에 반영하는 것 또한 항상 같은 결과를 보장해야 함

### 지갑 서비스 예시
- 지갑 서비스의 명령은 이체 요청임
- 명령은 FIFO 큐에 기록하며, 큐로는 카프카가 널리 사용됨
- 상태 기계는 명령을 큐에 들어간 순서대로 확인함
  - 명령을 읽을 때마다 충분한 잔액이 있는지 확인함
  - 충분할 경우 각 계정에 대한 이벤트를 만듦
  - a -> 1달러 -> c
    - 'a : -1달러"와 'c : +1달러'라는 두 개의 이벤트를 만듦
- 다섯 단계의 동작
  - a) 명령 대기열에서 명력을 읽음
  - b) DB에서 잔액 상태를 읽음
  - c) 명령 유효성 검사를 함. 유효할 경우 계정 별로 이벤트 생성
  - d) 다음 이벤트를 읽음
  - e) DB잔액을 갱신해 이벤트 적용을 마침

### 재현성
- 이벤트 소싱이 다른 아키텍처에 비해 갖는 가장 중요한 장점은 재현성임
- 분산 트랜잭션의 경우에는 지갑 서비스가 생신한 계정 잔액(상태)를 DB에 저장함
  - 계정 잔액이 변경된 이유는 알기가 어려움
  - 업데이트 후에는 과거 잔액이 얼마였는지 알 수 없음.
  - DB는 특정 시점의 잔액이 얼마인지만 보여줌
- 이벤트는 처음부터 다시 재생하면 과거 잔액 상태를 얼마든지 재구성 할 수 있음
- 이벤트 리스트는 불변이고, 상태 기계 로직은 결정론적이므로 이벤트 이력을 재생한 결과의 상태는 언제나 동일함
- 특정 시점의 계정 잔액을 알 수 있는가?
  - 시작부터 알고 싶은 시점까지 이벤트를 재생하면 됨
- 과거 및 현재 계정 잔액이 정확한지 어떻게 알 수 있는가?
  - 이벤트 이력에서 계정 잔액을 다시 계산해보면 잔액이 정확한지 알수 있음
- 코드 변경 후에도 시스템 로직이 올바른지 어떻게 증명하는가?
  - 새로운 코드에 동일한 이벤트 이력을 입력으로 주고 같은 결과가 나오는지 보면 됨
- 이러한 감사 요구 사항 때문에 이벤트 소싱이 지갑 서비스의 실질적인 솔루션으로 채택되는 경우가 많음
    
### 명령-질의 책임 분리(CQRS)
- 클라이언트는 여전히 계정의 잔액을 알 수 없음.
  - 이벤트 소싱 프레임워크 외부의 클라이언트가 상태를 알도록 할 방법이 필요함
- 이벤트 소싱은 상태(계정의 잔액)을 공개하는 대신 모든 이벤트를 외부에 보냄.
  - 이벤트를 수신하는 외부 주체가 직버 상태를 재구축할 수 있음
  - 이를 명령-질의 책임 분리(CQRS, Command Query Responsibility Separation)라고 부름
- CQRS에선느 상태를 기록하는 상태 기계는 하나고, 읽기 전용 상태 기계는 여러 개일 수 있다.
  - 읽기 전용 상태 기계는 상태 뷰를 만들고, 이 뷰는 질의에 이용됨
  - 예를 들어 잔액 질의 요청을 처리하기 위해 별도 DB에 상태를 기록하는 등의 작업을 할 수 있음
  - 이중 청구 등의 문제를 쉽게 조사하기 위해 특정 기간 동안의 상태를 복원할 수도 있음
  - 읽기 전용 상태 기계는 실제 상태에 어느 정도 뒤쳐질 수 있지만 결국에는 같아짐.
    - 결과적 일관성 모델을 따른다고 할 수 있음
- 이벤트 소싱 아키텍처는 한 번에 하나의 이벤트만 처리하고, 여러 외부 시스템과 통신해야함. 더 빠르게 만들 수는 없는가?

## 3단계 - 상세 설계
### 고성능 이벤트 소싱 - 파일 기반의 명령 및 이벤트 목록
- 명령과 이벤트를 카프카같은 원격 저장소가 아닌 로컬 디스크에 저장하는 방안을 생각해 볼 수 있음.
  - 네트워크 전송 시간을 피할 수 있음.
  - 이벤트 목록은 추가 연산만 가능한 자료 구조에 저장함
  - 추가는 순차적 쓰기 연산으로, 일반적으로 매우 빠름
  - 순차적 디스크 접근은 경우에 따라 무작위 메모리 접근보다 빠르게 실행될 수 있음
- 최근 명령과 이벤트를 메모리에 캐시하는 방안도 생각해볼 수 있음
  - 명령과 이벤트는 지속성 저장소에 보관된 후 처리됨.
  - 이를 메모리에 캐시해 놓으면 로컬 디스크에서 다시 로드하지 않아도 됨
- mmap은 로컬 디스크를 쓰는 동시에, 최근 데이터는 메모리에 자동으로 캐시할 수 있음
  - mmap은 디스크 파일을 메모리 배열에 대응 시킴

### 고성능 이벤트 소싱 - 파일 기반 상태
- 이전 설꼐안에서는 상태(잔액 정보)를 RDB에 저장함
  - 프로덕션 환경에서는 일반적으로 네트워크를 통해서만 접근 가능한 독립형 서버에 DB를 실행함
  - 명령 및 이벤트 저장소 최적화 방안과 마찬가지로 상태 정보도 로컬 디스크에 저장할 수 있음
  - 파일 기반 로컬 RDB SQLite를 사용하거나 로컬 파일 기반 Key-Value 저장소 RocksDB를 사용할 수 있음
- RocksDB는 쓰기 작업에 최적화된 자료 구조 LSM(Log-Structured Merge-tree)를 사용함.
  - 최근 데이터는 캐시해 읽기 성능을 높임

### 고성능 입네트 소싱 - 스냅샷
- 모든 것이 파일 기반일 때 재현 프로세스의 속도를 높일 방법은?
  - 처음에는 상태 기계를 사용해 이벤트를 항상 처음부터 읽어와 재현성을 확보함
  - 대신 주기적으로 상태 기계를 멈추고 현재 상태를 파일에 저장하면 시간을 절약할 수 있음. 이를 스냅샷이라고 부름
- 스냅샷은 과거 특정 시점의 상태로 변경이 불가능함
- 스냅샷은 거대한 이진 파일이며, 일반적으로 HDFS(Hadoop Distributed File System)와 같은 객체 저장소에 저장함

- 로컬 파일 기반 솔루션의 성능은 원격 카프카나 DB에 저장된 데이터를 액세스하는 시슽메보다 좋다고 할 수 있음.
- 다만, 로컬 디스크에 데이터를 저장하는 서버는 더 이상 무상태 서버가 아니며, 단일 장애 지점이 될 수 있음.
  - 시스템의 안정성을 개선할 필요가 있음

### 신뢰할 수 있는 고성능 이벤트 소싱 - 신뢰성 분석
- 서버 노드가 하는 일은 개념적으로 데이터와 연산이라는 두 가지 개념에 관계되어 있음.
- 데이터 내구성이 보장되는 한 계산 결과는 코드를 다른 노드에서 돌리면 복구할 수 있으므로 데이터의 신뢰성이 훨씬 중요함
- 따라서 시스템 신뢰성 문제는 데이터 신뢰성 문제인 경우가 많음
- 현재 설계 중인 시스템의 데이터 유형
  - 파일 기반 명령
  - 파일 기반 이벤트
  - 파일 기반 상태
  - 상태 스냅샷
- 상태와 스냅샷은 이벤트 목록을 재생하면 언제든 다시 만들 수 있음
  - 이벤트 목록의 신뢰성만 보장하면 됨
- 이벤트는 명령어에서 만들어지므로 명령의 신뢰성만 강력하게 보장하면 충분할 수 있지만, 이는 아님.
  - 이벤트 생성은 결정론적 과정이 아니고, 난수나 외부 입출력 등 무작위적 요소가 포함될 수 있기 때문에 명령의 신뢰성 만으로는 이벤트의 재현성을 보장할 수 없음
- 이벤트는 상태(잔액)에 변화를 가져 오는 과거의 사실임.
  - 이벤트는 불변이며, 상태 재구성에 사용할 수 있음
- 따라서 높은 신뢰성을 보장할 유일한 데이터는 이벤트다

### 합의
- 높은 안정성을 제공하려면 이벤트 목록을 여러 노드에 복제해야 함
  - 데이터 손실이 없어야 함
  - 로그 파일 내 데이터의 상대적 순서는 모든 노드에서 동일해야 함
- 합의 기반 복제를 사용하면 위 목표를 달성할 수 있음
  - 모든 노드가 동일한 이벤트 목록에 합의하도록 보장함
  - 레프트 알고리즘
    - 노드의 절반 이상이 온라인 상태면 그 모두에 보관된 추가 전용 리스트(append-only) 같은 데이터를 가짐

### 고신뢰성 솔루션
- 복제 메커니즘을 활용하면 파일 기반 이벤트 소싱 아키텍처에서 단일 지점 문제를 없앨 수 있음
- 래프트 알고리즘은 리더와 팔로어가 동일한 이벤트 목록을 갖도록 하며, 이벤트 소싱은 동일한 이벤트 목록에서 항상 동일한 상태가 만들어지도록 함
- 리더 노드에 장애가 발생하면 래프트 알고리즘은 나머지 정상 노드 중에서 새 리더를 선출함
  - 새 리더는 외부 사용자로부터 오는 명령을 수신할 책임을 지게 됨
  - 결과적으로 한 노드가 다운되어도 클러스터는 계속 서비스를 제공항 수 있게 됨
  - 주의할 것은 리더 장애가 명령 목록이 이벤트로 변환되기 전 발생할 수 있다는 것임.
  - 그럴 경우 클라이언트는 시간 초과 혹은 오류 응답을 받음.

### 분산 이벤트 소싱

