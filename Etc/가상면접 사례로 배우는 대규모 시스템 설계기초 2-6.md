# 11장 - 결제 시스템
## 1단계 - 문제 이해 및 설계 범위 확정
- 요구 사항 분석
  - Q) 어던 결제 시스템을 만들어야 하는가?
    - A) 아마존닷컴 같은 전자상거래 애플리케이션을 위한 결제 백엔드를 구축하나독 가정. 결제 시스템은 돈의 흐름에 대한 모든 것을 처리해야 함
  - Q) 어떤 결제 방법을 지원해야 하는가? 신용 카드, 페이팔, 은행 카드 등
    - A) 결제 시슽메은 실생활에서 사용 가능한 모든 옵션을 지원해야 함. 하지만 이번에는 신용 카드 결제만 처리함
  - Q) 신용 카드 결제 처리를 직접해야 하는가?
    - A) 아님. 스트라이프, 브레인트리(Braintree), 스퀘어(Square) 같은 전문 결제 서비스 업체를 사용함
  - Q) 신용 카드 데이터를 직접 저장해야 하는가?
    - A) 보안과 법규 준수 사항이 까다로우므로 카드 번호를 직접 저장하지는 않음. 민감한 신용카드 데이터 처리는 결제 처리 업체에 의존함
  - Q) 전 세계를 대상으로 하는가? 다양한 통화와 국제 결제를 지원해야 하는지?
    - A) 좋은 질문임. 전 세계적으로 사용되;지만 이번에는 하나의 통화만 사용한다고 가정함
  - Q) 하루 몇 건의 결제가 이루어지는가?
    - A) 하루 100만 건의 거래가 이루어진다고 가정함
  - Q) 아마존과 같은 전자상거래 사이트에서 매월 판매자에게 대금을 지급하는 절차를 지원하는가?
    - A) yes
  - Q) 추가로 주의해야할 것이 있는가?
    - A) 결제 시스템은 내부 서비스(계정, 분석 등) 및 외부 서비스(결제 서비스 공급자)와 연동함.
    - 한 서비스에 장애가 발생하면 서비스 간 상태가 달라지는 상황이 벌어질 수 있고, 이에 대한 조정 작업을 수행하고 불일치한 부분을 교정해야 함.

### 기능 요구사항
- 대금 수신(pay-in) 흐름
  - 결제 시스템이 판매자를 대신해 고객으로부터 대금을 수령함
- 대금 정산(pay-out) 흐름
  - 결제 시스템이 전 세계 판매자에게 제품 판매 대금을 송금함

### 비기능 요구사항
- 신뢰성 및 내결함성
  - 결제 실패는 신중하게 처리해야 함
- 내부 서비스(결제 시스템, 회계 시스템)와 외부 서비스(결제 서비스 제공업체) 간의 조정 프로세스
  - 시스템 간의 결제 정보가 일치하는지 비동기적으로 확인
ㅋ
### 개략적인 규모 추정
- 하루 100만 건의 트랜잭션을 처리해야 함
  - TPS는 10
    - 100만 / 10^5초
  - 10TPS는 일반적인 DB로 별 문제 없이 처리 가능하므로 처리 대역폭 대신 결제 트랜잭션의 정확한 처리에 초점을 맞춰 진행함

## 2단계 - 개략적 설계안 제시 및 동의 구하기
- 결제 흐름은 두 단계로 세분화 됨
  - 대금 수신 흐름
    - 구매자가 주분하면 아마존 은행 계좌로 돈이 들어오는 것
  - 대금 정산 흐름
    - 판매 완료 후 제품이 배송된 후에는 계좌에 있던 판매 대금에서 수수료를 제외한 잔액이 판매자의 은행 계좌로 지급됨

### 대금 수신 흐름 - 결제 서비스
- 사용자로부터 결제 이벤트를 수락하고 결제 프로세스를 조율함.
- 일반적으로 가장 먼저하는 것은 AML/CFT같은 규정을 준수하는지, 자금 세탁이나 테러 자금 조달과 같은 범죄 행위 증거가 없는지 평가하는 위험 점검임
  - 위험 확인 서비스는 매우 복잡하고 고도로 전문화되어 있어 제 3자 제공 업체를 이용함

### 결제 실행자
- 결제 실행자는 결제 서비스 공급자(PSP)를 토해 결제 주문 하나를 실행함
  - 하나의 결제 이벤트에는 여러 결제 주문이 포함될 수 있음

### 결제 서비스 공급자(PSP, Payment Service Provider)
- PSP는 A 계쩡에서 B 계정으로 돈을 옮기는 역할을 담당함

### 원장
- 원장은 결제 트랜잭션에 대한 금융 기록임
  - 사용자가 판매자에게 1달러를 결제하면 사용자로부터 1달러를 인출하고 판매자에게 1달러를 지급하는 기록을 남김
  - 원장 시스템은 전자상거래 웹 사이트의 총 수익을 계산하거나 향후 수익을 예측한느 등 결제 후 분석에서 매우 중요한 역할을 함

### 지갑
- 지갑은 판매자의 계정 잔액을 관리함
- 특정 사용자가 결제한 총 금액을 기록할 수도 있음
- 일반적인 결제 흐름
  - 사용자가 '주문하기' 버튼을 클릭하면 결제 이벤트가 생성되어 결제 서비스로 전송됨
  - 결제 서비스는 결제 이벤트를 DB에 저장함
  - 때로는 단일 결제 이벤트에 여러 결제 주문이 포함될 수 있음
    - 한 번 결제로 여러 판매자의 제품을 처리하는 경우 등
    - 웹사이트에서 한 결제를 여러 결제 주문으로 분할하는 경우, 결제 서비스는 결제 주문마다 결제 실행자를 호출함
  - 결제 실행자는 결제 주문을 DB에 저장함
  - 결제 실행자가 외부 PSP를 호출해 신용 카드 결제를 처리함
  - 결제 실행자가 결제를 성공적으로 처리하고 나면 결제 서비스는 지갑을 갱신해 특정 판매자의 잔고를 기록함
  - 지갑 서버는 갱신되고 잔고 정보를 DB에 저장함
  - 지갑 서비스가 판매자 잔고를 성공적으로 갱신하면 결제 서비스는 원장을 호출함
  - 원장 서비스는 새 원장 정보를 DB에 추가함

### 결제 서비스 API - POST /v1/payments
- 하나의 결제 이벤트에 여러 결제 주문이 포함될 수 있음

| 필드 | 설명 | 자료형    |
|------|------|--------|
| buyer_id | 구매자 정보 | json   |
| checkout_id | 해당 결제 이벤트를 식별하는 전역적으로 고유한 ID | string |
| credit_card_info | 암호화된 신용 카드 정보 또는 결제 토큰. PSP마다 다른 값 | json |
| payment_orders | 결제 주문 목록 | list |

- payment_orders

| 필드 | 설명                       | 자료형               |
|-----|--------------------------|-------------------|
| seller_account | 대금을 수령할 판매자              | string            |
| amount | 해당 주문으로 전송되어야 할 금액       | string            |
| currency | 주문에 사용된 통화 단위            | string (ISO 4217) |
| payment_order_id | 해당 주문을 식별하는 전역적으로 고유한 ID | string            |

- payment_order_id가 전역적으로 고유한 ID라는 것에 주의해야 함
- 결제 실행자가 타사 PSP에 결제 요청을 전송할 때, PSP는 payment_order_id를 중복 제거 ID로 사용함(멱등 키라고도 함)
- amount의 데이터 유형이 double이 아닌 이유
  - 프로토콜, 소프트웨어, 하드웨어에 따라 직렬화/역직렬화에 사용하는 숫자 정밀도가 다를 수 있음
    - 이는 의도치 않은 반올림 오류가 발생할 수 있음
  - 이 숫자가 매우 클 수도 있고, 매우 작을 수도 있음
  - 저장은 string으로 하고, 계산 시 숫자로 변환함

### 결제 서비스 API - GET /v1/payments/{:id}
- payment_order_id가 가리키는 단일 결제 주문의 실행 상태를 반환함

### 결제 서비스 데이터 모델
- 결제 서비스는 결제 입네트와 결제 주문의 두 개 테이블이 필요함.
- 결제 시스템용 저장소 솔루션을 고를 때 일반적으로 성능은 중요한 고려 사항이 아님
  - 안정성이 검증되었는가?
  - 다른 대형 금융사에서 수년 동안 긍정적인 피드백을 받으며 사용된 적이 있는가?
  - 모니터링 및 데이터 탐사(investigation) 도구가 있는가?
  - 숙련된 DBA를 쉽게 채용할 수 있는가?
- NoSQL/NewSQL보다는 ACID 트랜잭션을 지원하는 전통적은 RDB를 선호함
- 결제 이벤트

| 이름          | 자료형            |
|-------------|----------------|
| checkout_id | string PK      |
| buyer_info  | string         |
| seller_info | string         |
| credit_card_info | 카드 제공업체에 따라 다름 |
| is_payment_done | boolean        |

- 결제 주문

| 이름 | 자료형 |
|------|--------|
| payment_order_id | string PK |
| buyer_account | string |
| amount | string |
| currency | string |
| checkout_id | string FK |
| payment_order_status | string |
| ledger_updated | boolean |
| wallet_updated | boolean |

- checkout_id는 외래 키임
  - 한 번의 결제 행위는 하나의 결제 이벤트를 만들고, 하나의 결제 이벤트는 여러 개의 결제 주문이 포함될 수 있음
- 구매자의 신용 카드에서 금액을 공제하기 위해 타사 PSP를 호출하면 판매자가 대신 전자상거래 웹사이트의 은행 계좌에 이체가 이루어지는데, 이를 대금 수신이라 부름
  - 제품이 배송되는 등 대금 정산 조건 충족 시 해당 대금을 판매자에게 정산하는 절차를 시작함.
    - 따라서 사용자의 결제를 처리하는 중에는 판매자의 계좌가 아니라 구매자의 카드 정보만 필요함
- 결제 주문 테이블에서 payment_order_status는 결제 주문의 실행 상태를 유지하는 열거 자료형임
  - NOT_STARTED, EXECUTING, SUCCESS, FAILED 등이 있음
  - 업데이트 로직
    - payment_order_status의 초깃값은 NOT_STARTED임
    - 결제 서비스는 결제 실행자에 주문을 전송하면 payment_order_status의 값을 EXECUTING로 변경함
    - 결제 서비스는 결제 처리자의 응답에 따라 payment_order_status의 값을 SUCCESS 또는 FAILED로 변경함
  - SUCCESS 상태가 되면 결제 서비스는 지갑 서비스를 호출해 판매자의 잔액을 업데이트하고 wallet_updated를 true로 설정함
  - 이 절차 이후 다음 단계로 원장 서비스를 호출해 원장 DB의 ledger_updated를 true로 설정함
  - 동일한 checkout_id 아래 모든 결제 주문이 성공적으로 처리되면 결제 서비스는 결제 이벤트 테이블의 is_payment_done을 true로 설정함
  - 일반적으로 종결되지 않은 결제 주문을 모니터링하기 위해 주기적으로 실행되는 scheduled job을 마련해둠

### 복식부기 원장 시스템
- 복식부기(double-entry)는 원장 시스템에서 아주 중요한 설계 원칙임
  - 복식부기 회계(accounting)/부기(bookeeping)라고도 함
- 모든 결제 시스템에 필수 요소이며, 정확한 기록을 남기는 데 핵심적 역할을 함
- 모든 결제 거래를 두 개의 별도 원장 계좌에 같은 금액으로 기록함. 한 쪽에선 차감, 다른 한 쪽에서는 입긍미 이루어짐
- 복식부기 시스템에서 모든 거래 항목의 합계는 0이어야 함
- 이 시스템을 활용해 자금 흐름의 처음부터 끝을 추적할 수 있고, 결제 주기 전반에 걸쳐 일관성을 보장할 수 있다.

### 외부 결제 페이지
- 대부분의 기업은 복잡한 규정 때문에 신용 카드 정보를 내부에 저장하지 않는다.
  - 이를 위해서 PSP에서 제공하는 외부 신용 카드 페이지를 사용함
  - 웹사이트에서는 위젯 또는 iframe이고, 모바일에서는 결제 SDK가 포함된 사전에 구현된 페이지다.

### 대금 정산 흐름
- 대금 정산 흐름의 구성 요소는 대금 수신 흐름과 아주 유사함.
- 한 가지 차이는 PSP를 사용해 구매자의 신용 카드에서 전자상거래 웹사이트 은행으로 이체하는 대신, 정산 흐름에서는 타사 정산 서비스를 사용해 전자상거래 웹사이트 은행 계좌에서 판매자 은행 계좌로 돈을 이체한다는 점임

## 3단계 - 상세 설계

### PSP 연동
- 결제 시스템이 은행이나 비자 또는 마스터카드같은 카드 시스템에 직접 연결할 수 있으면 PSP 없이도 결제가 가능함
- 일반적으로 직접 연결에 투자할 수 있는 것은 아주 큰 회사 뿐임
- 일반적인 결제 시스템과 PSP 연동 방법
  - 회사가 민감한 결제 정보를 안전하게 저장할 수 있으면 API를 통해 PSP와 연동하는 방법을 선택할 수 있음.
    - 회사가 결제 웹페이지를 개발하고 민감한 결제 정보를 수집하며, PSP는 은행 연결, 다양한 카드 유형을 지원하는 역할을 함
  - 복합한 규정과 보안 문제로 민감한 결제 정보를 저장하지 않기로 한 경우, PSP는 카드 결제 세부 정보를 수집해 PSP에 안전하게 저장할 수 있도록 외부 결제 페이지를 제공함
    - 대부분의 기업이 선택하는 접근법임
- 간결한 전체 결제 프로세스
  - 사용자가 클라이언트 브라우저에서 '결제' 버튼을 클릭함.(클라가 결제 주문 정볼르 담아 결제 서비스를 호출함)
  - 결제 주문 정보를 수신한 결제 서비스는 결제 등록 요청(payment registration request)을 PSP에 전송함
    - 결제 금액, 통화, 결제 요청 만료일, 리디렉션 URL 등의 결제 정보가 포함됨.
    - 정확히 한 번 등록되도록 UUID 필드를 둠.
      - 일반적으로 결제 주문의 ID로 사용됨
  - PSP는 결제 서비스에 토큰을 반환함.
    - 토큰은 등록된 결제 요청을 유일하게 식별하는, PSP가 발급한 UUID임
    - 이 코튼을 이용해 결제 등록 및 결제 실행 상태를 확인함
  - 결제 서비스는 PSP가 제공하는 외부 결제 페이지를 호추하기 전에 토큰을 DB에 저장
  - 토큰을 저장하고 나면 클라는 PSP가 제공하는 외부 결제 페이지를 표시함.
    - 애플리케이션은 일반적으로 이를 위해 PSP SDK를 연동함
    - 민감한 결제 정보는 PSP가 수집
    - 외부 결제 페이지가 필요한 정보
      - 4단계에서 받은 토큰
        - PSP의 JS는 이 토큰을 사용해 PSP의 백엔드에서 결제 요청에 대한 상세 정보를 검색함
        - 이 과정에서 사용자에게 받을 금액은 중요한 정보 중 하나임
      - 리디렉션 URL
        - 결제가 완료되면 호출될 URL
        - PSP의 JS는 결제가 완료되면 브라우저를 리디렉션 URL로 보냄
        - 일반적으로 리디렉션 URL은 결제 상태를 표시하는 웹 사이트 상의 한 페이지임
        - 웹훅 URL과는 다르다는 것을 알아야 함
  - 사용자는 카드 번호, 소유자 이름 등의 결제 세부 정보를 PSP의 웹 페이지에 입력하고 결제를 요청함
  - PSP가 결제 상태를 반환함
  - 리디렉션 URL이 가리키는 웹 페이지로 보내짐
    - 보통 7단계에서 수신된 결제 상태가 URL에 추가됨
      - host_url/?tokenId={tokenId}&payResult={payResult}
  - 비동기적으로 PSP는 웹훅을 통해 결제 상태와 함께 결제 서비스를 호출함
    - 웹훅은 결제 시스템 측에서 PSP를 처음 설정할 때 등록한 URL임
    - 결제 시스템이 웹훅을 통해 결제 이벤트를 다시 수신하면 결제 상태를 추출해 결제 주문 DB의 payment_order_status를 업데이트함

### 조정
- 위 9단계 중 네트워크 등으로 장애 발생 시 처리하는 방법
- 조정이란 관련 서비스 간의 상태를 주기적으로 비교해 일치하는지 확인하는 것
- 매일 밤 PSP나 은행은 고객에게 정산 파일을 보냄.
  - 은핵 계좌의 잔액과 하루 동안 해당 계좌에서 발생한 모든 거래(transaction) 내역이 기재됨
- 조정 시스템은 정산 파일의 세부 정보를 읽어 원장 시스템과 비교함
- 조정은 결제 시스템의 내부 일관성을 확인할 때에도 사용됨
  - 원장과 지갑 상태가 같은지 등에서도 사용됨
- 발생 가능한 불일치 문제 및 해결 방안
  - 어떤 유형의 문제인지 알고 문제 해결 절차를 자동화할 수 있는 경우
    - 원인과 해결 방법을 알고 있고, 자동화하는 것이 비용 효율적인 경우.
    - 불일치 문제의 분류와 조정 작업을 모두 자동화 가능
  - 문제는 알지만 해결 절차를 자동화할 수 없는 경우
    - 불일치의 원인과 해결 방법은 알지만 자동화하는 비용이 너무 높을 때
    - 작업 대기열에 넣고 재무팀에서 수동으로 조정하도록 함
  - 분류할 수 없는 유형의 문제인 경우
    - 불일치가 어떻게 발생했는지 알지 못하는 경우
    - 이런 경우 특별 작업 대기열에 넣고 재무팀에서 조사하도록 함

### 결제 지연 처리
- 대부분 몇 초 안에 처리되지만, 완료/거부까지 몇 시간 또는 며칠이 걸리는 경우가 있음
  - PSP가 해당 결제 요청의 위험성이 높다고 판단해 담당자 검토를 요구하는 경우
  - 신용 카드사가 구매 확인 용도로 카드 소유자의 추가 정보를 요청하는 3D 보안 인증 같은 추가 보호 장치를 요구하는 경우
- 구매 페이지가 외부 PSP에 호스팅 되는 경우
  - PSP는 결제가 대기 상태에 있음을 클라이언트에 알리고, 클라이언트가 사용자에게 표시함
  - PSP는 대기 중인 결제 진행 상황을 추적하고 상태가 바뀌면 PSP에 등록된 웹훅을 통해 결제 서비스에 알림
  - 결제 요청이 완료되면 PSP는 웹훅을 호출함.
  - 이후 결제 서비스는 내부 시스템에 정보를 업데이트함

### 내부 서비스 간 커뮤니케이션 - 동기식 통신
- HTTP 같은 통신은 소규모 시스템에서는 잘 동작하지만, 규모가 커지면 단점이 명확해짐
- 성능 저하
  - 요청 처리에 관계된 서비스 하나의 성능 문제가 전체 시스템에 영향을 줌
- 장애 격리 곤란
  - PSP 등의 서비스에 장애 발생 시 클라이언트는 더 이상 응답을 받지 못 함
- 높은 결합도
  - 요청 발신자는 수신자를 알아야 함
- 낮은 확장성
  - 큐를 버퍼로 사용하지 않고는 갑작스러운 트래픽 증가에 대응할 수 있게 시스템 확장이 어려움

### 내부 서비스 간 커뮤니케이션 - 비동기 통신
- 단일 수신자
  - 각 요청(메시지)은 하나의 수신자 또는 서비스가 처리함
  - 일반적으로 공유 메시지 큐를 사용해 구현함
  - 큐에는 여러 구독자가 있을 수 있지만, 처리된 메시지는 큐에서 바로 제거됨
- 다중 수신자
  - 각 요청(메시지)은 여러 수신자나 서버가 처리함
  - 카프카가 이런 시나리오를 잘 처리함
  - 소비자가 수신한 메시지는 카프카에서 바로 사라지지 않음
  - 동일한 메시지를 여러 서비스가 받아서 사용할 수 있으므로 결제 시스템 구현에 적합함
    - 하나의 요청을 푸시 알림 전송, 재무 보고 업데이트, 분석 결과 업데이트 등 다양한 용도로 사용 가능
- 동기식 통신은 설계하기 쉽지만, 서비스의 자율성을 높이기에는 적합하지 않음.
- 의존성 그래프가 커지면 전반적인 성능이 낮아짐
- 비동기는 설계의 단순성과 데이터 일관성을 시스템 확장성 및 장애 감내 능력과 맞바꾸는 결과임
- 비즈니스 로직이 복잡하고 타사 서비스 의존성이 높은 대규모 결제 시스템에서는 비동기 통신이 더 나은 선택임

### 결제 실패 처리 - 결제 상태 추적
- 결제 실패 처리에서 결제 상태를 정확하게 유지하는 것은 매우 중요한 요구사항임
- 실패가 발생할 때마다 결제의 현재 상태를 파악하고 재시도 또는 환불 여부 등을 결정함
- 결제 상태는 데이터 추가만 가능한 DB 테이블에 보관함

### 결제 실패 처리 - 재시도 큐 및 실패 메시지 큐
- 실패를 우아하게 처리하기 위해서는 재시도 큐와 실패 메시지 큐를 두는 것이 바람직 함
- 재시도 큐
  - 일시적 오류 같은 재시도 가능 오류는 재시도 큐에 보냄
- 실패 메시지 큐
  - 반복적으로 처리 실패한 메시지는 결국 실패 메시지 큐로 보냄
  - 문제가 잇는 메시지를 디버깅하고 격리해 성공적으로 처리되지 않은 이유를 파악하는 데 유용함
- 재시도 가능한지 확인
  - a) 재시도 가능 실패는 재시도 큐로 보냄
  - b) 잘못된 입력과 같이 재시도가 불가능한 실패는 오류 내역을 DB에 저장함
- 결제 시스템은 재시도 큐에 쌓인 이벤트를 읽어 실패한 결제를 재시도함
- 결제 거래가 다시 실패하는 경우에는 다음과 같이 처리함
  - a) 재시도 횟수가 임계값 이내일 경우 해당 이벤트를 다시 재시도 큐로 보냄
  - b) 재시도 횟수가 임계값을 넘으면 해당 이벤트를 실패 메시지 큐에 넣음.(별도 조사가 필요할 수도 있음)

### 정확히 한 번 전달
- 


### Q) 결제 상태를 데이터 추가만 가능한 DB 테이블에 보관하는 이유는?