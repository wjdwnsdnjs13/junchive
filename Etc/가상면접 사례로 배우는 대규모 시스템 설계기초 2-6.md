# 11장 - 결제 시스템
## 1단계 - 문제 이해 및 설계 범위 확정
- 요구 사항 분석
  - Q) 어던 결제 시스템을 만들어야 하는가?
    - A) 아마존닷컴 같은 전자상거래 애플리케이션을 위한 결제 백엔드를 구축하나독 가정. 결제 시스템은 돈의 흐름에 대한 모든 것을 처리해야 함
  - Q) 어떤 결제 방법을 지원해야 하는가? 신용 카드, 페이팔, 은행 카드 등
    - A) 결제 시슽메은 실생활에서 사용 가능한 모든 옵션을 지원해야 함. 하지만 이번에는 신용 카드 결제만 처리함
  - Q) 신용 카드 결제 처리를 직접해야 하는가?
    - A) 아님. 스트라이프, 브레인트리(Braintree), 스퀘어(Square) 같은 전문 결제 서비스 업체를 사용함
  - Q) 신용 카드 데이터를 직접 저장해야 하는가?
    - A) 보안과 법규 준수 사항이 까다로우므로 카드 번호를 직접 저장하지는 않음. 민감한 신용카드 데이터 처리는 결제 처리 업체에 의존함
  - Q) 전 세계를 대상으로 하는가? 다양한 통화와 국제 결제를 지원해야 하는지?
    - A) 좋은 질문임. 전 세계적으로 사용되;지만 이번에는 하나의 통화만 사용한다고 가정함
  - Q) 하루 몇 건의 결제가 이루어지는가?
    - A) 하루 100만 건의 거래가 이루어진다고 가정함
  - Q) 아마존과 같은 전자상거래 사이트에서 매월 판매자에게 대금을 지급하는 절차를 지원하는가?
    - A) yes
  - Q) 추가로 주의해야할 것이 있는가?
    - A) 결제 시스템은 내부 서비스(계정, 분석 등) 및 외부 서비스(결제 서비스 공급자)와 연동함.
    - 한 서비스에 장애가 발생하면 서비스 간 상태가 달라지는 상황이 벌어질 수 있고, 이에 대한 조정 작업을 수행하고 불일치한 부분을 교정해야 함.

### 기능 요구사항
- 대금 수신(pay-in) 흐름
  - 결제 시스템이 판매자를 대신해 고객으로부터 대금을 수령함
- 대금 정산(pay-out) 흐름
  - 결제 시스템이 전 세계 판매자에게 제품 판매 대금을 송금함

### 비기능 요구사항
- 신뢰성 및 내결함성
  - 결제 실패는 신중하게 처리해야 함
- 내부 서비스(결제 시스템, 회계 시스템)와 외부 서비스(결제 서비스 제공업체) 간의 조정 프로세스
  - 시스템 간의 결제 정보가 일치하는지 비동기적으로 확인
ㅋ
### 개략적인 규모 추정
- 하루 100만 건의 트랜잭션을 처리해야 함
  - TPS는 10
    - 100만 / 10^5초
  - 10TPS는 일반적인 DB로 별 문제 없이 처리 가능하므로 처리 대역폭 대신 결제 트랜잭션의 정확한 처리에 초점을 맞춰 진행함

## 2단계 - 개략적 설계안 제시 및 동의 구하기
- 결제 흐름은 두 단계로 세분화 됨
  - 대금 수신 흐름
    - 구매자가 주분하면 아마존 은행 계좌로 돈이 들어오는 것
  - 대금 정산 흐름
    - 판매 완료 후 제품이 배송된 후에는 계좌에 있던 판매 대금에서 수수료를 제외한 잔액이 판매자의 은행 계좌로 지급됨

### 대금 수신 흐름 - 결제 서비스
- 사용자로부터 결제 이벤트를 수락하고 결제 프로세스를 조율함.
- 일반적으로 가장 먼저하는 것은 AML/CFT같은 규정을 준수하는지, 자금 세탁이나 테러 자금 조달과 같은 범죄 행위 증거가 없는지 평가하는 위험 점검임
  - 위험 확인 서비스는 매우 복잡하고 고도로 전문화되어 있어 제 3자 제공 업체를 이용함

### 결제 실행자
- 결제 실행자는 결제 서비스 공급자(PSP)를 토해 결제 주문 하나를 실행함
  - 하나의 결제 이벤트에는 여러 결제 주문이 포함될 수 있음

### 결제 서비스 공급자(PSP, Payment Service Provider)
- PSP는 A 계쩡에서 B 계정으로 돈을 옮기는 역할을 담당함

### 원장
- 원장은 결제 트랜잭션에 대한 금융 기록임
  - 사용자가 판매자에게 1달러를 결제하면 사용자로부터 1달러를 인출하고 판매자에게 1달러를 지급하는 기록을 남김
  - 원장 시스템은 전자상거래 웹 사이트의 총 수익을 계산하거나 향후 수익을 예측한느 등 결제 후 분석에서 매우 중요한 역할을 함

### 지갑
- 지갑은 판매자의 계정 잔액을 관리함
- 특정 사용자가 결제한 총 금액을 기록할 수도 있음
- 일반적인 결제 흐름
  - 사용자가 '주문하기' 버튼을 클릭하면 결제 이벤트가 생성되어 결제 서비스로 전송됨
  - 결제 서비스는 결제 이벤트를 DB에 저장함
  - 때로는 단일 결제 이벤트에 여러 결제 주문이 포함될 수 있음
    - 한 번 결제로 여러 판매자의 제품을 처리하는 경우 등
    - 웹사이트에서 한 결제를 여러 결제 주문으로 분할하는 경우, 결제 서비스는 결제 주문마다 결제 실행자를 호출함
  - 결제 실행자는 결제 주문을 DB에 저장함
  - 결제 실행자가 외부 PSP를 호출해 신용 카드 결제를 처리함
  - 결제 실행자가 결제를 성공적으로 처리하고 나면 결제 서비스는 지갑을 갱신해 특정 판매자의 잔고를 기록함
  - 지갑 서버는 갱신되고 잔고 정보를 DB에 저장함
  - 지갑 서비스가 판매자 잔고를 성공적으로 갱신하면 결제 서비스는 원장을 호출함
  - 원장 서비스는 새 원장 정보를 DB에 추가함

### 결제 서비스 API - POST /v1/payments
- 하나의 결제 이벤트에 여러 결제 주문이 포함될 수 있음

| 필드 | 설명 | 자료형    |
|------|------|--------|
| buyer_id | 구매자 정보 | json   |
| checkout_id | 해당 결제 이벤트를 식별하는 전역적으로 고유한 ID | string |
| credit_card_info | 암호화된 신용 카드 정보 또는 결제 토큰. PSP마다 다른 값 | json |
| payment_orders | 결제 주문 목록 | list |

- payment_orders

| 필드 | 설명                       | 자료형               |
|-----|--------------------------|-------------------|
| seller_account | 대금을 수령할 판매자              | string            |
| amount | 해당 주문으로 전송되어야 할 금액       | string            |
| currency | 주문에 사용된 통화 단위            | string (ISO 4217) |
| payment_order_id | 해당 주문을 식별하는 전역적으로 고유한 ID | string            |

- payment_order_id가 전역적으로 고유한 ID라는 것에 주의해야 함
- 결제 실행자가 타사 PSP에 결제 요청을 전송할 때, PSP는 payment_order_id를 중복 제거 ID로 사용함(멱등 키라고도 함)
- amount의 데이터 유형이 double이 아닌 이유
  - 프로토콜, 소프트웨어, 하드웨어에 따라 직렬화/역직렬화에 사용하는 숫자 정밀도가 다를 수 있음
    - 이는 의도치 않은 반올림 오류가 발생할 수 있음
  - 이 숫자가 매우 클 수도 있고, 매우 작을 수도 있음
  - 저장은 string으로 하고, 계산 시 숫자로 변환함

### 결제 서비스 API - GET /v1/payments/{:id}
- payment_order_id가 가리키는 단일 결제 주문의 실행 상태를 반환함

### 결제 서비스 데이터 모델
- 결제 서비스는 결제 입네트와 결제 주문의 두 개 테이블이 필요함.
- 결제 시스템용 저장소 솔루션을 고를 때 일반적으로 성능은 중요한 고려 사항이 아님
  - 안정성이 검증되었는가?
  - 다른 대형 금융사에서 수년 동안 긍정적인 피드백을 받으며 사용된 적이 있는가?
  - 모니터링 및 데이터 탐사(investigation) 도구가 있는가?
  - 숙련된 DBA를 쉽게 채용할 수 있는가?
- NoSQL/NewSQL보다는 ACID 트랜잭션을 지원하는 전통적은 RDB를 선호함
- 결제 이벤트

| 이름          | 자료형            |
|-------------|----------------|
| checkout_id | string PK      |
| buyer_info  | string         |
| seller_info | string         |
| credit_card_info | 카드 제공업체에 따라 다름 |
| is_payment_done | boolean        |

- 결제 주문

| 이름 | 자료형 |
|------|--------|
| payment_order_id | string PK |
| buyer_account | string |
| amount | string |
| currency | string |
| checkout_id | string FK |
| payment_order_status | string |
| ledger_updated | boolean |
| wallet_updated | boolean |

- checkout_id는 외래 키임
  - 한 번의 결제 행위는 하나의 결제 이벤트를 만들고, 하나의 결제 이벤트는 여러 개의 결제 주문이 포함될 수 있음
- 구매자의 신용 카드에서 금액을 공제하기 위해 타사 PSP를 호출하면 판매자가 대신 전자상거래 웹사이트의 은행 계좌에 이체가 이루어지는데, 이를 대금 수신이라 부름
  - 제품이 배송되는 등 대금 정산 조건 충족 시 해당 대금을 판매자에게 정산하는 절차를 시작함.
    - 따라서 사용자의 결제를 처리하는 중에는 판매자의 계좌가 아니라 구매자의 카드 정보만 필요함
- 결제 주문 테이블에서 payment_order_status는 결제 주문의 실행 상태를 유지하는 열거 자료형임
  - NOT_STARTED, EXECUTING, SUCCESS, FAILED 등이 있음
  - 업데이트 로직
    - payment_order_status의 초깃값은 NOT_STARTED임
    - 결제 서비스는 결제 실행자에 주문을 전송하면 payment_order_status의 값을 EXECUTING로 변경함
    - 결제 서비스는 결제 처리자의 응답에 따라 payment_order_status의 값을 SUCCESS 또는 FAILED로 변경함
  - SUCCESS 상태가 되면 결제 서비스는 지갑 서비스를 호출해 판매자의 잔액을 업데이트하고 wallet_updated를 true로 설정함
  - 이 절차 이후 다음 단계로 원장 서비스를 호출해 원장 DB의 ledger_updated를 true로 설정함
  - 동일한 checkout_id 아래 모든 결제 주문이 성공적으로 처리되면 결제 서비스는 결제 이벤트 테이블의 is_payment_done을 true로 설정함
  - 일반적으로 종결되지 않은 결제 주문을 모니터링하기 위해 주기적으로 실행되는 scheduled job을 마련해둠

### 복식부기 원장 시스템
- 복식부기(double-entry)는 원장 시스템에서 아주 중요한 설계 원칙임
  - 복식부기 회계(accounting)/부기(bookeeping)라고도 함
- 모든 결제 시스템에 필수 요소이며, 정확한 기록을 남기는 데 핵심적 역할을 함
- 모든 결제 거래를 두 개의 별도 원장 계좌에 같은 금액으로 기록함. 한 쪽에선 차감, 다른 한 쪽에서는 입긍미 이루어짐
- 복식부기 시스템에서 모든 거래 항목의 합계는 0이어야 함
- 이 시스템을 활용해 자금 흐름의 처음부터 끝을 추적할 수 있고, 결제 주기 전반에 걸쳐 일관성을 보장할 수 있다.

### 외부 결제 페이지
- 대부분의 기업은 복잡한 규정 때문에 신용 카드 정보를 내부에 저장하지 않는다.
  - 이를 위해서 PSP에서 제공하는 외부 신용 카드 페이지를 사용함
  - 웹사이트에서는 위젯 또는 iframe이고, 모바일에서는 결제 SDK가 포함된 사전에 구현된 페이지다.

### 대금 정산 흐름
- 대금 정산 흐름의 구성 요소는 대금 수신 흐름과 아주 유사함.
- 한 가지 차이는 PSP를 사용해 구매자의 신용 카드에서 전자상거래 웹사이트 은행으로 이체하는 대신, 정산 흐름에서는 타사 정산 서비스를 사용해 전자상거래 웹사이트 은행 계좌에서 판매자 은행 계좌로 돈을 이체한다는 점임

## 3단계 - 상세 설계

### PSP 연동